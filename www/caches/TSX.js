// generated by VivioJS 22.02 build 0 : 14-Feb-22 14:27:45

"use strict"

function TSX(vplayer) {

	// preload fonts
	let font = new FontFace('Open Sans', 'url("../fonts/open-sans-v18-latin-regular.woff")', {weight:400})
	font.load()
	document.fonts.add(font)
	font = new FontFace('Open Sans', 'url("../fonts/open-sans-v18-latin-700.woff")', {weight:700})
	font.load()
	document.fonts.add(font)
	font = new FontFace('Open Sans', 'url("../fonts/open-sans-v18-latin-italic.woff")', {style:'italic', weight:400})
	font.load()
	document.fonts.add(font)

	// const imports
	const ARROW60_END = vplayer.ARROW60_END
	const ARROW60_START = vplayer.ARROW60_START
	const BLACK = vplayer.BLACK
	const BLUE = vplayer.BLUE
	const CYAN = vplayer.CYAN
	const GRAY128 = vplayer.GRAY128
	const GRAY160 = vplayer.GRAY160
	const GRAY192 = vplayer.GRAY192
	const GRAY224 = vplayer.GRAY224
	const GRAY32 = vplayer.GRAY32
	const GRAY64 = vplayer.GRAY64
	const GRAY96 = vplayer.GRAY96
	const GREEN = vplayer.GREEN
	const HLEFT = vplayer.HLEFT
	const HRIGHT = vplayer.HRIGHT
	const ITALIC = vplayer.ITALIC
	const JUSTIFY = vplayer.JUSTIFY
	const MAGENTA = vplayer.MAGENTA
	const MB_CTRL = vplayer.MB_CTRL
	const MB_LEFT = vplayer.MB_LEFT
	const PROPAGATE = vplayer.PROPAGATE
	const RED = vplayer.RED
	const REMEMBER = vplayer.REMEMBER
	const ROUND_END = vplayer.ROUND_END
	const ROUND_START = vplayer.ROUND_START
	const SMALLCAPS = vplayer.SMALLCAPS
	const VBOTTOM = vplayer.VBOTTOM
	const VCENTRE = vplayer.VCENTRE
	const VTOP = vplayer.VTOP
	const WHITE = vplayer.WHITE
	const YELLOW = vplayer.YELLOW

	// var imports
	var $addWaitToEventQ = vplayer.$addWaitToEventQ
	var $g = vplayer.$g
	var $terminateThread = vplayer.$terminateThread
	var checkPoint = vplayer.checkPoint
	var debug = vplayer.debug
	var EXTENDEDGOBJ = vplayer.EXTENDEDGOBJ
	var Font = vplayer.Font
	var fork = vplayer.fork
	var getArgAsNum = vplayer.getArgAsNum
	var getLastModifiedMS = vplayer.getLastModifiedMS
	var getTick = vplayer.getTick
	var getURL = vplayer.getURL
	var Group = vplayer.Group
	var Line = vplayer.Line
	var Line2 = vplayer.Line2
	var newArray = vplayer.newArray
	var Rectangle = vplayer.Rectangle
	var Rectangle2 = vplayer.Rectangle2
	var reset = vplayer.reset
	var rgba = vplayer.rgba
	var setBgBrush = vplayer.setBgBrush
	var setTPS = vplayer.setTPS
	var setVirtualWindow = vplayer.setVirtualWindow
	var SolidBrush = vplayer.SolidBrush
	var SolidPen = vplayer.SolidPen
	var sprintf = vplayer.sprintf
	var start = vplayer.start
	var timeToString = vplayer.timeToString
	var Txt = vplayer.Txt
	var VObj = vplayer.VObj

	// const declarations
	const W=1024
	const H=640
	const TITLEX=10
	const TITLEY=10
	const TITLEH=40
	const BY=10
	const BW=100
	const BH=30
	const INFOX=TITLEX
	const INFOY=60
	const INFOW=350
	const INFOH=150
	const MEMY=50
	const MEMW=180
	const MEMH=120
	const ABUSY=280
	const ABUSW=12
	const DBUSY=240
	const DBUSW=12
	const SBUSY=320
	const SBUSW=8
	const CACHEY=370
	const CACHEW=MEMW
	const CACHEH=60
	const CPUY=490
	const CPUW=CACHEW
	const CPUH=80
	const TY=CPUY+CPUH+5
	const BUSOPY=208
	const NCPU=3
	const NADDR=4
	const NSET=2
	const TICKS=20
	const INVALID=0
	const SHARED=1
	const EXCLUSIVE=2
	const MODIFIED=3

	var $thread = 0
	var $pc = 0
	var $fp = -1
	var $sp = -1
	var $acc = 0
	var $obj = 0
	var $stack = 0
	var $testFlag = 0

	function $call(pc, obj) {
		if (obj === undefined)
			obj = 0
		let l = arguments.length - 1
		for (let i = l; i >= 2; i--)
			$stack[++$sp] = arguments[i]
		$acc = obj
		$stack[++$sp] = $pc + 1
		$pc = pc
		return $acc
	}

	function $enter(n) {	// n = # local variables
		$stack[++$sp] = $obj
		$stack[++$sp] = $fp
		$fp = $sp
		$obj = $acc
		$sp += n
	}

	function $return(n) {	// n = # parameters to pop
		$sp = $fp
		$fp = $stack[$sp--]
		$obj = $stack[$sp--]
		$pc = $stack[$sp--]
		if ($pc == -1) {
			$terminateThread($thread)
			$thread = 0
			return
		}
		$sp -= n
	}

	function $suspendThread() {
		if ($thread == 0)
			return 0;
		$thread.pc = $pc
		$thread.fp = $fp
		$thread.sp = $sp
		$thread.acc = $acc
		$thread.obj = $obj
		return $thread
	}

	function $getCurrentThread() {
		return $thread
	}

	function $resumeThread(toThread) {
		$pc = toThread.pc
		$fp = toThread.fp
		$sp = toThread.sp
		$acc = toThread.acc
		$obj = toThread.obj
		$stack = toThread.stack
		$thread = toThread
	}

	function $switchToThread(toThread) {
		if ($thread == toThread) {
			$acc = toThread.acc
			return
		}
		$suspendThread()
		$resumeThread(toThread)
	}

	function wait(ticks) {
		$suspendThread()
		$addWaitToEventQ(ticks, $thread)	// -ve ticks for a realtime wait
		return 1
	}

	function SimpleButton($grp, x, y, w, h, _b0, _b1, p0, _p1, txtpen, _f1, _f2, txt) {
		Group.call(this, $grp, 0, ((0) | EXTENDEDGOBJ), x, y, 0, 0, w, h)
		this.$b0=_b0
		this.$b1=_b1
		this.$p1=_p1
		this.$f1=_f1
		this.$f2=_f2
		this.$enabled=1
		this.setPen(p0)
		this.setBrush(this.$b0)
		this.setTxtPen(txtpen)
		this.setFont(this.$f1)
		this.setTxt(txt)
		this.setRounded(4, 4)
		this.$buttonFG=new Rectangle2(this, 0, 0, 0, 0, 1, 1, w-2, h-2)
		this.$buttonFG.setRounded(4, 4)
		this.addEventHandler("eventEE", this, this.$eh0)
		this.addEventHandler("eventMB", this, this.$eh1)
	}
	SimpleButton.prototype = Object.create(Group.prototype)

	SimpleButton.prototype.$eh0 = function(enter, $1, $2) {
		this.setBrush(enter ? this.$b1 : this.$b0)
		return PROPAGATE
	}

	SimpleButton.prototype.$eh1 = function(down, $1, $2, $3) {
		if (this.$enabled) {
			this.setFont(down ? this.$f2 : this.$f1)
			this.$buttonFG.setPen(down ? this.$p1 : 0)
		}
		return PROPAGATE
	}

	function Bus(x, y, w, l, fgColour) {
		VObj.call(this)
		this.$busPen=new SolidPen(0, w, fgColour, ARROW60_START|ARROW60_END)
		this.$arrow=new Line2($g[0], 0, 0, this.$busPen, x, y, l, 0)
	}
	Bus.prototype = Object.create(VObj.prototype)

	Bus.prototype.$setColour = function(colour) {
		this.$busPen.setRGBA(colour)
	}

	function BusArrow(x, y, w, _l, bgColour, fgColour) {
		VObj.call(this)
		this.$l=_l
		this.$bgPen=new SolidPen(0, w, bgColour, ARROW60_START|ARROW60_END)
		this.$bgArrow=new Line2($g[0], 0, 0, this.$bgPen, x, y, 0, this.$l)
		this.$fgPen=new SolidPen(0, w, fgColour, ARROW60_END)
		this.$fgArrow=new Line2($g[0], 0, 0, this.$fgPen, x, y, 0, 0)
		this.$fgArrow.setOpacity(0)
	}
	BusArrow.prototype = Object.create(VObj.prototype)

	BusArrow.prototype.$reset = function() {
		this.$bgArrow.setOpacity(1)
		this.$fgArrow.setOpacity(0)
	}

	function Memory(_x, _y) {
		VObj.call(this)
		this.$mem=newArray(NADDR)
		this.$stale=newArray(NADDR)
		this.$memR=newArray(NADDR)
		this.$x=_x
		this.$y=_y
		this.$bgap=3
		this.$bw=MEMW-2*this.$bgap
		this.$bh=(MEMH-(NADDR+1)*this.$bgap)/NADDR
		this.$r=new Rectangle2($g[0], 0, 0, $g[1], $g[29], this.$x, this.$y, MEMW, MEMH)
		this.$r.setRounded(4, 4)
		new Rectangle2($g[0], 0, 0, 0, 0, this.$x, this.$y-30, MEMW, 25, $g[3], $g[41], "MEMORY")
		this.$abus=new BusArrow(this.$x+50, this.$y+MEMH, ABUSW, ABUSY-this.$y-MEMH-ABUSW/2, GRAY32, BLUE)
		this.$dbus=new BusArrow(this.$x+100, this.$y+MEMH, DBUSW, DBUSY-this.$y-MEMH-DBUSW/2, GRAY32, RED)
		for (this.$i=0; this.$i<NADDR; this.$i++) {
			this.$mem[this.$i]=10
			this.$stale[this.$i]=0
			this.$memR[this.$i]=new Rectangle2($g[0], 0, 0, $g[1], $g[17], this.$x+this.$bgap, this.$y+(this.$i+1)*this.$bgap+this.$i*this.$bh, this.$bw, this.$bh, $g[1], $g[37], "address: a%d data: %d", this.$i, this.$mem[this.$i])
			this.$memR[this.$i].setRounded(2, 2)
		}
	}
	Memory.prototype = Object.create(VObj.prototype)

	Memory.prototype.$highlight = function(addr, flag) {
		this.$memR[addr].setBrush((flag) ? $g[19] : (this.$stale[addr]) ? $g[29] : $g[17])
	}

	Memory.prototype.$reset = function() {
		for (let i=0; i<NADDR; i++)
		this.$highlight(i, 0)
	}

	function showBusOp(s) {
		$g[58].setTxt(s)
		let w=$g[58].getTxtW()+16
		$g[58].setPt(0, -w/2, -10)
		$g[58].setPt(1, w/2, 10)
		$g[58].setOpacity(1, TICKS, 0)
	}

	function Cache(x, y, _cpuN) {
		VObj.call(this)
		this.$aR=newArray(NSET), this.$dR=newArray(NSET), this.$stateR=newArray(NSET), this.$tbitR=newArray(NSET)
		this.$a=newArray(NSET), this.$d=newArray(NSET), this.$state=newArray(NSET), this.$tbit=newArray(NSET)
		this.$cpuN=_cpuN
		this.$bgap=3
		this.$bw0=20
		this.$bw1=(CACHEW-5*this.$bgap-2*this.$bw0)/2
		this.$bh=(CACHEH-(NSET+1)*this.$bgap)/NSET
		this.$sharedbus=new BusArrow(x+this.$bgap+this.$bw0/2, SBUSY+SBUSW/2, SBUSW, y-SBUSY-SBUSW/2, GRAY32, MAGENTA)
		this.$abus=new BusArrow(x+2*this.$bgap+this.$bw0+this.$bw1/2, ABUSY+ABUSW/2, ABUSW, y-ABUSY-ABUSW/2, GRAY32, BLUE)
		this.$dbus=new BusArrow(x+3*this.$bgap+this.$bw0+3*this.$bw1/2, DBUSY+DBUSW/2, DBUSW, y-DBUSY-DBUSW/2, GRAY32, RED)
		this.$cpuabus=new BusArrow(x+CACHEW/4, y+CACHEH, ABUSW, CPUY-CACHEY-CACHEH, GRAY32, BLUE)
		this.$cpudbus=new BusArrow(x+3*CACHEW/4, y+CACHEH, DBUSW, CPUY-CACHEY-CACHEH, GRAY32, RED)
		this.$r=new Rectangle2($g[0], 0, 0, $g[1], $g[29], x, y, CACHEW, CACHEH)
		this.$r.setRounded(4, 4)
		new Txt($g[0], 0, HLEFT|VTOP, x+CACHEW-20, y-30, $g[3], $g[41], "CACHE %d", this.$cpuN)
		$g[58].moveToFront()
		for (this.$i=0; this.$i<NSET; this.$i++) {
			this.$state[this.$i]=INVALID
			this.$stateR[this.$i]=new Rectangle2($g[0], 0, 0, $g[1], $g[17], x+this.$bgap, y+(this.$i+1)*this.$bgap+this.$i*this.$bh, this.$bw0, this.$bh, $g[1], $g[37], "I")
			this.$stateR[this.$i].setRounded(2, 2)
			this.$tbit[this.$i]=0
			this.$tbitR[this.$i]=new Rectangle2($g[0], 0, 0, $g[1], $g[17], x+2*this.$bgap+this.$bw0, y+(this.$i+1)*this.$bgap+this.$i*this.$bh, this.$bw0, this.$bh, $g[1], $g[37])
			this.$tbitR[this.$i].setRounded(2, 2)
			this.$a[this.$i]=0
			this.$aR[this.$i]=new Rectangle2($g[0], 0, 0, $g[1], $g[17], x+3*this.$bgap+2*this.$bw0, y+(this.$i+1)*this.$bgap+this.$i*this.$bh, this.$bw1, this.$bh, $g[1], $g[37])
			this.$aR[this.$i].setRounded(2, 2)
			this.$d[this.$i]=0
			this.$dR[this.$i]=new Rectangle2($g[0], 0, 0, $g[1], $g[17], x+4*this.$bgap+2*this.$bw0+this.$bw1, y+(this.$i+1)*this.$bgap+this.$i*this.$bh, this.$bw1, this.$bh, $g[1], $g[37])
			this.$dR[this.$i].setRounded(2, 2)
		}
	}
	Cache.prototype = Object.create(VObj.prototype)

	Cache.prototype.$setValues = function(set, addr, data) {
		this.$a[set]=addr
		this.$aR[set].setTxt("a%d", addr)
		this.$d[set]=data
		this.$dR[set].setTxt("%d", data)
	}

	Cache.prototype.$highlight = function(set, flag) {
		let brush=flag ? $g[19] : $g[17]
		this.$stateR[set].setBrush(brush)
		this.$tbitR[set].setBrush(brush)
		this.$aR[set].setBrush(brush)
		this.$dR[set].setBrush(brush)
	}

	Cache.prototype.$reset = function() {
		this.$cpuabus.$reset()
		this.$cpudbus.$reset()
		this.$highlight(0, 0)
		this.$highlight(1, 0)
	}

	Cache.prototype.$resetBus = function() {
		$g[57].$abus.$reset()
		$g[57].$dbus.$reset()
		$g[55].$setColour(GRAY32)
		$g[54].$setColour(GRAY32)
		$g[56].$setColour(GRAY32)
		$g[57].$reset()
		for (let i=0; i<NCPU; i++) {
			$g[60][i].$abus.$reset()
			$g[60][i].$dbus.$reset()
			$g[60][i].$sharedbus.$reset()
		}
		$g[58].setOpacity(0, TICKS, 0)
	}

	Cache.prototype.$startTransaction = function() {
		this.$r.setPen($g[35])
	}

	Cache.prototype.$endTransaction = function() {
		this.$r.setPen($g[1])
		for (let set=0; set<NSET; set++) {
			this.$tbit[set]=0
			this.$tbitR[set].setTxt("")
			if (this.$state[set]==MODIFIED) {
				$g[57].$stale[this.$a[set]]=1
				$g[57].$memR[this.$a[set]].setBrush($g[29])
			}
		}
	}

	Cache.prototype.$abortTransaction = function() {
		this.$r.setPen($g[1])
		for (let set=0; set<NSET; set++) {
			if ((this.$state[set]==MODIFIED)&&this.$tbit[set]) {
				this.$state[set]=INVALID
				this.$stateR[set].setTxt("I")
			}
			this.$tbit[set]=0
			this.$tbitR[set].setTxt("")
		}
	}

	function CPU(x, y, _cpuN) {
		VObj.call(this)
		this.$cpuN=_cpuN
		this.$bgap=3
		this.$bw=(CPUW-4*this.$bgap)/3
		this.$bh=(CPUH-(NADDR+1)*this.$bgap)/NADDR
		this.$tbw=(CPUW-4*this.$bgap)/3
		this.$buttonLock=0
		this.$selected
		this.$transaction=0
		this.$readB=newArray(NADDR)
		this.$incB=newArray(NADDR)
		this.$decB=newArray(NADDR)
		this.$r=new Rectangle2($g[0], 0, 0, $g[1], $g[29], x, y, CPUW, CPUH)
		this.$r.setRounded(4, 4)
		new Txt($g[0], 0, HLEFT|VTOP, x+CPUW-20, y-30, $g[3], $g[41], "CPU %d", this.$cpuN)
		for (this.$i=0; this.$i<NADDR; this.$i++) {
			this.$readB[this.$i]=new this.$CPUButton(this, $g[0], 0, x+this.$bgap, y+(this.$i+1)*this.$bgap+this.$i*this.$bh, this.$bw, this.$i)
			this.$incB[this.$i]=new this.$CPUButton(this, $g[0], 1, x+2*this.$bgap+this.$bw, y+(this.$i+1)*this.$bgap+this.$i*this.$bh, this.$bw, this.$i)
			this.$decB[this.$i]=new this.$CPUButton(this, $g[0], 2, x+3*this.$bgap+2*this.$bw, y+(this.$i+1)*this.$bgap+this.$i*this.$bh, this.$bw, this.$i)
		}
		this.$tR=new Rectangle($g[0], 0, 0, $g[1], $g[29], x, TY, 0, 0, CPUW, 2*this.$bgap+this.$bh)
		this.$tR.setRounded(4, 4)
		this.$xbeginButton=new SimpleButton($g[0], x+this.$bgap, TY+this.$bgap, this.$tbw, this.$bh, $g[17], $g[30], $g[10], $g[12], $g[1], $g[39], $g[40], "xbegin")
		this.$xendButton=new SimpleButton($g[0], x+2*this.$bgap+this.$tbw, TY+this.$bgap, this.$tbw, this.$bh, $g[17], $g[30], $g[10], $g[12], $g[1], $g[39], $g[40], "xend")
		this.$xabortButton=new SimpleButton($g[0], x+3*this.$bgap+2*this.$tbw, TY+this.$bgap, this.$tbw, this.$bh, $g[17], $g[30], $g[10], $g[12], $g[1], $g[39], $g[40], "xabort")
		this.$abortLR=new Line($g[0], 0, 0, $g[31], x, y, 4, 4, CPUW-8, CPUH-8)
		this.$abortRL=new Line($g[0], 0, 0, $g[31], x, y, 4, CPUH-4, CPUW-8, -CPUH+8)
		this.$abortLR.setOpacity(0)
		this.$abortRL.setOpacity(0)
		this.$tStatus=new Rectangle2($g[0], 0, 0, 0, 0, x, TY+3*this.$bgap+this.$bh, CPUW, 20, $g[3], $g[41], "")
		this.$xbeginButton.addEventHandler("eventMB", this, this.$eh3)
		this.$xendButton.addEventHandler("eventMB", this, this.$eh4)
		this.$xabortButton.addEventHandler("eventMB", this, this.$eh5)
	}
	CPU.prototype = Object.create(VObj.prototype)

	CPU.prototype.$CPUButton = function($parent, $grp, _op, x, y, bw, _addr) {
		this.parent = $parent
		SimpleButton.call(this, $grp, x, y, bw, this.parent.$bh, $g[17], $g[30], $g[10], $g[12], $g[1], $g[39], $g[40], "")
		this.$op=_op
		this.$addr=_addr
		this.setTxt(this.$op==0 ? "read a%d" : this.$op==1 ? "inc a%d" : "dec a%d", this.$addr)
		this.addEventHandler("eventMB", this, 112)
	}
	CPU.prototype.$CPUButton.prototype = Object.create(SimpleButton.prototype)

	CPU.prototype.$CPUButton.prototype.$select = function() {
		if (this.parent.$selected==this) {
			this.parent.$selected.setPen($g[10])
			this.parent.$selected=0
		} else {
			if (this.parent.$selected)
			this.parent.$selected.setPen($g[10])
			this.parent.$selected=this
			this.parent.$selected.setPen($g[34])
		}
	}

	CPU.prototype.$CPUButton.prototype.$resetCPUs = function(cpuN) {
		for (let i=0; i<NCPU; i++) {
			if ($g[61][i].$selected==0) {
				$g[60][i].$reset()
				$g[61][i].$resetButtons()
			}
		}
	}

	CPU.prototype.$resetButtons = function() {
		for (let i=0; i<NADDR; i++) {
			if (this.$selected!=this.$readB[i])
			this.$readB[i].setPen($g[10])
			if (this.$selected!=this.$incB[i])
			this.$incB[i].setPen($g[10])
			if (this.$selected!=this.$decB[i])
			this.$decB[i].setPen($g[10])
			this.$tStatus.setTxt(this.$transaction ? "Transaction in Progress" : "")
			this.$abortLR.setOpacity(0)
			this.$abortRL.setOpacity(0)
		}
	}

	CPU.prototype.$startTransaction = function() {
		if (this.$transaction==0&&this.$buttonLock==0) {
			this.$transaction=1
			$g[60][this.$cpuN].$startTransaction()
			this.$r.setPen($g[35])
			this.$abortLR.setOpacity(0)
			this.$abortRL.setOpacity(0)
			this.$tStatus.setTxt("Transaction in Progress")
		}
	}

	CPU.prototype.$endTransaction = function() {
		if (this.$transaction&&this.$buttonLock==0) {
			this.$transaction=0
			$g[60][this.$cpuN].$endTransaction()
			this.$r.setPen($g[1])
			this.$tStatus.setTxt("Transaction COMMIT")
		}
	}

	CPU.prototype.$abortTransaction = function() {
		debug("abortTransaction")
		if (this.$transaction) {
			this.$transaction=0
			$g[60][this.$cpuN].$abortTransaction()
			this.$r.setPen($g[1])
			this.$abortRL.setOpacity(1)
			this.$abortLR.setOpacity(1)
			this.$tStatus.setTxt("Transaction ABORT")
		}
	}

	CPU.prototype.$eh3 = function(down, flags, $2, $3) {
		if (down&&(flags&MB_LEFT)) {
			this.$startTransaction()
			start()
		}
	}

	CPU.prototype.$eh4 = function(down, flags, $2, $3) {
		if (down&&(flags&MB_LEFT)) {
			this.$endTransaction()
			start()
		}
	}

	CPU.prototype.$eh5 = function(down, flags, $2, $3) {
		if (down&&(flags&MB_LEFT)&&(this.$buttonLock==0)) {
			this.$abortTransaction()
			start()
		}
	}

	function $eh7(down, flags, $2, $3) {
		if (down&&(flags&MB_LEFT)) {
			if ($g[49]==2) {
				$g[49]=0
				$g[63].setTxt("bug free!")
			} else {
				$g[49]++
				$g[63].setTxt("bug %d", $g[49]-1)
			}
		}
		return 0
	}

	function $eh8(down, flags, $2, $3) {
		if (down&&(flags&MB_LEFT))
		getURL("TSXHelp.htm")
		return 0
	}

	function $eh9(down, flags, $2, $3) {
		if (down&&(flags&MB_LEFT))
		getURL("../vivio.htm")
		return 0
	}

	function $execute(thread) {

		$switchToThread(thread);

		while (1) {
			switch ($pc) {
			case -1:
				return;		// catch thread termination
			case 0:
				$enter(0)	// start with a function call
				$g[1]=new SolidPen(0, 0, BLACK)
				$g[2]=new SolidPen(0, 0, WHITE)
				$g[3]=new SolidPen(0, 0, RED)
				$g[4]=new SolidPen(0, 0, GREEN)
				$g[5]=new SolidPen(0, 0, BLUE)
				$g[6]=new SolidPen(0, 0, YELLOW)
				$g[7]=new SolidPen(0, 0, MAGENTA)
				$g[8]=new SolidPen(0, 0, CYAN)
				$g[9]=new SolidPen(0, 0, GRAY32)
				$g[10]=new SolidPen(0, 0, GRAY64)
				$g[11]=new SolidPen(0, 0, GRAY96)
				$g[12]=new SolidPen(0, 0, GRAY128)
				$g[13]=new SolidPen(0, 0, GRAY160)
				$g[14]=new SolidPen(0, 0, GRAY192)
				$g[15]=new SolidPen(0, 0, GRAY224)
				$g[16]=new SolidBrush(BLACK)
				$g[17]=new SolidBrush(WHITE)
				$g[18]=new SolidBrush(RED)
				$g[19]=new SolidBrush(GREEN)
				$g[20]=new SolidBrush(BLUE)
				$g[21]=new SolidBrush(YELLOW)
				$g[22]=new SolidBrush(MAGENTA)
				$g[23]=new SolidBrush(CYAN)
				$g[24]=new SolidBrush(GRAY32)
				$g[25]=new SolidBrush(GRAY64)
				$g[26]=new SolidBrush(GRAY96)
				$g[27]=new SolidBrush(GRAY128)
				$g[28]=new SolidBrush(GRAY160)
				$g[29]=new SolidBrush(GRAY192)
				$g[30]=new SolidBrush(GRAY224)
				setVirtualWindow(0, 0, W, H, 1)
				setTPS(20)
				$g[31]=new SolidPen(0, 4, RED, ROUND_START|ROUND_END)
				$g[32]=new SolidPen(0, 2, rgba(0, 0.59999999999999998, 0), ROUND_END)
				$g[33]=new SolidPen(0, 2, GRAY64, ROUND_END)
				$g[34]=new SolidPen(0, 2, rgba(1, 0.65000000000000002, 0), ROUND_END)
				$g[35]=new SolidPen(0, 2, RED, ROUND_END)
				$g[36]=new SolidBrush(rgba(0, 0.56000000000000005, 0.16))
				$g[37]=new Font("Open Sans", 16, 0)
				$g[38]=new Font("Open Sans", 14, 0)
				$g[39]=new Font("Open Sans", 12, 0)
				$g[40]=new Font("Open Sans", 10, 0)
				$g[41]=new Font("Open Sans", 18, SMALLCAPS)
				$g[42]=new Font("Open Sans", 14, 0)
				$g[43]=new Font("Open Sans", 18, SMALLCAPS)
				$g[44]=new Font("Open Sans", 10, ITALIC)
				$g[45]=new Font("Open Sans", 28, 0)
				setBgBrush($g[30])
				$g[46]=new Rectangle2($g[0], 0, 0, 0, $g[36], TITLEX, TITLEY, W/2, TITLEH, $g[2], $g[45], "Intel TSX MESI Cache")
				$g[46].setRounded(5, 5)
				$g[46].setTxtOff(0, 2)
				$g[46].setPt(1, $g[46].getTxtW()+16, TITLEH)
				$g[47]="Like real hardware, the CPUs can operate in\n"
				$g[47]+="parallel. Try pressing a button on different\n"
				$g[47]+="CPUs \"simultaneously\". Alternatively select\n"
				$g[47]+="buttons on different CPUs with the CTRL key and\n"
				$g[47]+="click on the last button without CTRL to start\n"
				$g[47]+="simultaneous transactions."
				new Rectangle2($g[0], 0, HLEFT|VCENTRE|JUSTIFY, 0, 0, INFOX, INFOY, INFOW, INFOH, $g[1], $g[42], $g[47])
				new Txt($g[0], 0, HRIGHT|VBOTTOM, W-10, H-10, $g[14], $g[44], timeToString(getLastModifiedMS(), "last modified %e-%b-%y"))
				$g[48]=(W-3*CPUW-2*CPUW)/2
				$g[49]=0
				$g[50]=-1
				$g[51]=0
				$g[52]=-1
				$g[53]=0
				$g[54]=new Bus(10, DBUSY, DBUSW, W-40, GRAY32)
				new Txt($g[0], 0, 0, $g[48]+CACHEW+CACHEW/2-40, DBUSY-20, $g[3], $g[43], "data bus")
				$g[55]=new Bus(20, ABUSY, ABUSW, W-40, GRAY32)
				new Txt($g[0], 0, 0, $g[48]+CACHEW+CACHEW/2, ABUSY-20, $g[5], $g[43], "address bus")
				$g[56]=new Bus(30, SBUSY, SBUSW, W-40, GRAY32)
				new Txt($g[0], 0, 0, $g[48]+CACHEW+CACHEW/2, SBUSY-15, $g[7], $g[43], "shared")
				$g[57]=new Memory((W-MEMW)/2, MEMY)
				$g[58]=new Rectangle($g[0], 0, 0, $g[1], $g[17], W/2, BUSOPY, 0, 0, 0, 0, 0, $g[42])
				$g[58].setOpacity(0)
				$g[58].setRounded(4, 4)
				$g[58].setTxtOff(0, 1)
				$g[59]=new Txt($g[0], 0, HLEFT, 2*W/3, (ABUSY+DBUSY)/2, 0, $g[43], "bus cycles: %d", $g[53])
				$g[60]=newArray(NCPU)
				$g[61]=newArray(NCPU)
				$g[60][0]=new Cache((W-3*CACHEW-2*CACHEW)/2, CACHEY, 0)
				$g[60][1]=new Cache((W-3*CACHEW-2*CACHEW)/2+CACHEW+CACHEW, CACHEY, 1)
				$g[60][2]=new Cache((W-3*CACHEW-2*CACHEW)/2+2*CACHEW+2*CACHEW, CACHEY, 2)
				$g[61][0]=new CPU((W-3*CPUW-2*CPUW)/2, CPUY, 0)
				$g[61][1]=new CPU((W-3*CPUW-2*CPUW)/2+CPUW+CPUW, CPUY, 1)
				$g[61][2]=new CPU((W-3*CPUW-2*CPUW)/2+2*CPUW+2*CPUW, CPUY, 2)
				$g[62]=new SimpleButton($g[0], W-2*BW-2*BW/8, BY, BW, BH, $g[17], $g[30], $g[33], $g[12], $g[1], $g[37], $g[38], "reset")
				$g[63]=new SimpleButton($g[0], W-BW-BW/8, BY, BW, BH, $g[17], $g[30], $g[33], $g[12], $g[1], $g[37], $g[38], "bug free!")
				$g[64]=new SimpleButton($g[0], W-2*BW-2*BW/8, BY+BH+BH/4, BW, BH, $g[17], $g[30], $g[33], $g[12], $g[1], $g[37], $g[38], "help")
				$g[65]=new SimpleButton($g[0], W-BW-BW/8, BY+BH+BH/4, BW, BH, $g[17], $g[30], $g[33], $g[12], $g[1], $g[37], $g[38], "VivioJS help")
				$g[62].addEventHandler("eventMB", $obj, 128)
				$g[63].addEventHandler("eventMB", $obj, $eh7)
				$g[64].addEventHandler("eventMB", $obj, $eh8)
				$g[65].addEventHandler("eventMB", $obj, $eh9)
				if (!(getArgAsNum("selfTest", 0))) {
					$pc = 4
					continue
				}
				$g[61][0].$startTransaction()
				$g[61][1].$startTransaction()
				$call(103, $g[61][0].$incB[0])
				continue
			case 1:
				$call(103, $g[61][1].$readB[0])
				continue
			case 2:
				$call(103, $g[61][1].$incB[0])
				continue
			case 3:
				$g[61][1].$endTransaction()
				debug("FINISHED tick=%d", getTick())
				$pc = 4
			case 4:
				$return(0)
				continue
			case 5:
				$enter(0);	// moveUp
				$obj.$fgArrow.setPt(0, 0, $obj.$l)
				$obj.$fgArrow.setPt(1, 0, $obj.$l)
				$obj.$fgArrow.setPt(1, 0, 0, $stack[$fp-3], 0)
				$obj.$fgArrow.setOpacity(1, $stack[$fp-3]/4, 0)
				$pc = 6
				if ($obj.$bgArrow.setOpacity(0, $stack[$fp-3], $stack[$fp-4])) {
					return
				}
			case 6:
				$return(2)
				continue
			case 7:
				$enter(0);	// moveDown
				$obj.$fgArrow.setPt(0, 0, 0)
				$obj.$fgArrow.setPt(1, 0, 0)
				$obj.$fgArrow.setPt(1, 0, $obj.$l, $stack[$fp-3], 0)
				$obj.$fgArrow.setOpacity(1, $stack[$fp-3]/4, 0)
				$pc = 8
				if ($obj.$bgArrow.setOpacity(0, $stack[$fp-3], $stack[$fp-4])) {
					return
				}
			case 8:
				$return(2)
				continue
			case 9:
				$enter(2);	// flush
				$stack[$fp+1]=$stack[$fp-3]%NSET
				$stack[$fp+2]=$obj.$a[$stack[$fp+1]]
				$call(5, $obj.$abus, TICKS, 0)
				continue
			case 10:
				$call(5, $obj.$dbus, TICKS, 1)
				continue
			case 11:
				$g[55].$setColour(BLUE)
				$g[54].$setColour(RED)
				$call(5, $g[57].$abus, TICKS, 0)
				continue
			case 12:
				$call(5, $g[57].$dbus, TICKS, 1)
				continue
			case 13:
				$obj.$state[$stack[$fp+1]]=EXCLUSIVE
				$obj.$stateR[$stack[$fp+1]].setTxt("E")
				$g[57].$stale[$stack[$fp+2]]=0
				$g[57].$memR[$stack[$fp+2]].setBrush($g[17])
				$g[57].$mem[$stack[$fp+2]]=$obj.$d[$stack[$fp+1]]
				$g[57].$memR[$stack[$fp+2]].setTxt("address: a%d data: %d", $stack[$fp+2], $g[57].$mem[$stack[$fp+2]])
				$obj.$resetBus()
				$return(1)
				continue
			case 14:
				$enter(2);	// busWatchHelper
				$stack[$fp+1]=$stack[$fp-3]%NSET
				$stack[$fp+2]=($obj.$a[$stack[$fp+1]]==$stack[$fp-3])&&($obj.$state[$stack[$fp+1]]!=INVALID)
				if (!($stack[$fp+2]&&$stack[$fp-4]==0)) {
					$pc = 16
					continue
				}
				$g[51]=($obj.$state[$stack[$fp+1]]==MODIFIED&&$obj.$tbit[$stack[$fp+1]]) ? 0 : 1
				if (!($obj.$state[$stack[$fp+1]]==MODIFIED)) {
					$pc = 15
					continue
				}
				$g[50]=$obj.$cpuN
				$pc = 15
			case 15:
				$pc = 16
			case 16:
				$call(7, $obj.$abus, TICKS, 1)
				continue
			case 17:
				if (!($stack[$fp+2]==0)) {
					$pc = 18
					continue
				}
				$return(2)
				continue
			case 18:
				if (!($stack[$fp-4]==0)) {
					$pc = 24
					continue
				}
				if (!($obj.$state[$stack[$fp+1]]==MODIFIED&&$obj.$tbit[$stack[$fp+1]])) {
					$pc = 19
					continue
				}
				$g[50]=-1
				$g[61][$obj.$cpuN].$abortTransaction()
				$return(2)
				continue
			case 19:
				if (!(($obj.$state[$stack[$fp+1]]==EXCLUSIVE)||($obj.$state[$stack[$fp+1]]==MODIFIED))) {
					$pc = 22
					continue
				}
				if (!($obj.$state[$stack[$fp+1]]==MODIFIED)) {
					$pc = 21
					continue
				}
				$g[60][$obj.$cpuN].$highlight($stack[$fp+1], 1)
				$call(5, $g[60][$obj.$cpuN].$dbus, TICKS, 0)
				continue
			case 20:
				$pc = 21
			case 21:
				$obj.$state[$stack[$fp+1]]=SHARED
				$obj.$stateR[$stack[$fp+1]].setTxt("S")
				$obj.$highlight($stack[$fp+1], 1)
				$pc = 22
			case 22:
				$call(5, $obj.$sharedbus, TICKS, 1)
				continue
			case 23:
				$g[56].$setColour(MAGENTA)
				$pc = 26
				continue
			case 24:
				debug("cpu=%d set=%d tbit[set]=%d transaction=%d", $obj.$cpuN, $stack[$fp+1], $obj.$tbit[$stack[$fp+1]], $g[61][$obj.$cpuN].$transaction)
				if (!($obj.$tbit[$stack[$fp+1]])) {
					$pc = 25
					continue
				}
				$g[61][$obj.$cpuN].$abortTransaction()
				$pc = 25
			case 25:
				$obj.$state[$stack[$fp+1]]=INVALID
				$obj.$stateR[$stack[$fp+1]].setTxt("I")
				$obj.$highlight($stack[$fp+1], 1)
				$pc = 26
			case 26:
				$return(2)
				continue
			case 27:
				$enter(1);	// busWatch
				$g[50]=-1
				$g[51]=0
				$stack[$fp+1]=0
				$pc = 28
			case 28:
				if (!($stack[$fp+1]<NCPU)) {
					$pc = 31
					continue
				}
				if (!($stack[$fp+1]!=$stack[$fp-4])) {
					$pc = 29
					continue
				}
				fork(14, $g[60][$stack[$fp+1]], $stack[$fp-3], $stack[$fp-5])
				$pc = 29
			case 29:
				$pc = 30
			case 30:
				$stack[$fp+1]++
				$pc = 28
				continue
			case 31:
				if (!($stack[$fp-5]==0)) {
					$pc = 34
					continue
				}
				$pc = 32
				if (wait(2*TICKS)) {
					return
				}
			case 32:
				$call(7, $g[60][$stack[$fp-4]].$sharedbus, TICKS, 0)
				continue
			case 33:
				$pc = 34
			case 34:
				$return(3)
				continue
			case 35:
				$enter(0);	// getBusLock
				if (!($g[52]==$obj.$cpuN)) {
					$pc = 36
					continue
				}
				$return(0)
				continue
			case 36:
				$pc = 37
			case 37:
				if (!($g[52]>=0)) {
					$pc = 39
					continue
				}
				$pc = 38
				if (wait(1)) {
					return
				}
			case 38:
				$pc = 37
				continue
			case 39:
				$g[52]=$obj.$cpuN
				$return(0)
				continue
			case 40:
				$enter(0);	// releaseBusLock
				$g[52]=-1
				$pc = 41
				if (wait(1)) {
					return
				}
			case 41:
				$return(0)
				continue
			case 42:
				$enter(1);	// read
				$g[58].setOpacity(0)
				$stack[$fp+1]=$stack[$fp-3]%NSET
				if (!($stack[$fp-4])) {
					$pc = 44
					continue
				}
				$call(5, $obj.$cpuabus, TICKS, 1)
				continue
			case 43:
				$pc = 44
			case 44:
				if (!($obj.$a[$stack[$fp+1]]!=$stack[$fp-3]&&$obj.$tbit[$stack[$fp+1]]==1)) {
					$pc = 45
					continue
				}
				$g[61][$obj.$cpuN].$abortTransaction()
				$return(2)
				continue
			case 45:
				if (!(($obj.$a[$stack[$fp+1]]==$stack[$fp-3])&&($obj.$state[$stack[$fp+1]]!=INVALID))) {
					$pc = 52
					continue
				}
				if (!($g[61][$obj.$cpuN].$transaction&&$obj.$tbit[$stack[$fp+1]]==0&&$obj.$state[$stack[$fp+1]]==MODIFIED)) {
					$pc = 49
					continue
				}
				showBusOp(sprintf("CPU %d flushes a%d from its cache to memory", $obj.$cpuN, $stack[$fp-3]))
				$call(9, $obj, $stack[$fp-3])
				continue
			case 46:
				$g[53]++
				$g[59].setTxt("bus cycles: %d", $g[53])
				$call(40, $obj)
				continue
			case 47:
				$call(35, $obj)
				continue
			case 48:
				$obj.$resetBus()
				$pc = 49
			case 49:
				$obj.$tbit[$stack[$fp+1]]=$g[61][$obj.$cpuN].$transaction
				$obj.$tbitR[$stack[$fp+1]].setTxt($obj.$tbit[$stack[$fp+1]] ? "T" : "")
				$obj.$highlight($stack[$fp+1], 1)
				if (!($stack[$fp-4])) {
					$pc = 51
					continue
				}
				$call(7, $obj.$cpudbus, TICKS, 1)
				continue
			case 50:
				$pc = 51
			case 51:
				$return(2)
				continue
			case 52:
				$call(35, $obj)
				continue
			case 53:
				$obj.$resetBus()
				if (!(($obj.$state[$stack[$fp+1]]==MODIFIED)&&($g[49]!=2))) {
					$pc = 57
					continue
				}
				showBusOp(sprintf("CPU %d flushes a%d from its cache to memory", $obj.$cpuN, $stack[$fp-3]))
				$call(9, $obj, $stack[$fp-3])
				continue
			case 54:
				$g[53]++
				$g[59].setTxt("bus cycles: %d", $g[53])
				$call(40, $obj)
				continue
			case 55:
				$call(35, $obj)
				continue
			case 56:
				$obj.$resetBus()
				$pc = 57
			case 57:
				showBusOp(sprintf("CPU %d reads a%d from memory", $obj.$cpuN, $stack[$fp-3]))
				$g[53]++
				$g[59].setTxt("bus cycles: %d", $g[53])
				$obj.$highlight($stack[$fp+1], 1)
				$call(5, $obj.$abus, TICKS, 1)
				continue
			case 58:
				$g[55].$setColour(BLUE)
				$call(5, $g[57].$abus, TICKS, 0)
				continue
			case 59:
				fork(27, $obj, $stack[$fp-3], $obj.$cpuN, 0)
				$pc = 60
				if (wait(TICKS)) {
					return
				}
			case 60:
				if (!($g[50]>=0)) {
					$pc = 64
					continue
				}
				$pc = 61
				if (wait(TICKS)) {
					return
				}
			case 61:
				showBusOp(sprintf("CPU %d reads a%d from memory - CPU %d intervenes and supplies data from its cache", $obj.$cpuN, $stack[$fp-3], $g[50]))
				$g[54].$setColour(RED)
				$call(5, $g[57].$dbus, TICKS, 0)
				continue
			case 62:
				$call(7, $obj.$dbus, TICKS, 1)
				continue
			case 63:
				$g[57].$mem[$stack[$fp-3]]=$g[60][$g[50]].$d[$stack[$fp+1]]
				$g[57].$stale[$stack[$fp-3]]=0
				$g[57].$memR[$stack[$fp-3]].setBrush($g[17])
				$g[57].$memR[$stack[$fp-3]].setTxt("address: a%d data: %d", $stack[$fp-3], $g[57].$mem[$stack[$fp-3]])
				$g[57].$highlight($stack[$fp-3], 1)
				$pc = 67
				continue
			case 64:
				$g[57].$highlight($stack[$fp-3], 1)
				$call(7, $g[57].$dbus, TICKS, 1)
				continue
			case 65:
				$g[54].$setColour(RED)
				$call(7, $obj.$dbus, TICKS, 1)
				continue
			case 66:
				$pc = 67
			case 67:
				$obj.$a[$stack[$fp+1]]=$stack[$fp-3]
				$obj.$aR[$stack[$fp+1]].setTxt("a%d", $stack[$fp-3])
				$obj.$d[$stack[$fp+1]]=$g[57].$mem[$stack[$fp-3]]
				$obj.$dR[$stack[$fp+1]].setTxt("%d", $obj.$d[$stack[$fp+1]])
				$obj.$state[$stack[$fp+1]]=$g[51] ? SHARED : EXCLUSIVE
				$obj.$stateR[$stack[$fp+1]].setTxt($g[51] ? "S" : "E")
				$obj.$tbit[$stack[$fp+1]]=$g[61][$obj.$cpuN].$transaction
				$obj.$tbitR[$stack[$fp+1]].setTxt($obj.$tbit[$stack[$fp+1]] ? "T" : "")
				$call(40, $obj)
				continue
			case 68:
				if (!($stack[$fp-4])) {
					$pc = 70
					continue
				}
				$call(7, $obj.$cpudbus, TICKS, 1)
				continue
			case 69:
				$pc = 70
			case 70:
				$return(2)
				continue
			case 71:
				$enter(2);	// write
				$g[58].setOpacity(0)
				$stack[$fp+1]=$stack[$fp-3]%NSET
				$call(5, $obj.$cpudbus, TICKS, 0)
				continue
			case 72:
				$call(5, $obj.$cpuabus, TICKS, 1)
				continue
			case 73:
				$obj.$highlight($stack[$fp+1], 1)
				$stack[$fp+2]=$g[61][$obj.$cpuN].$transaction
				if (!(($obj.$a[$stack[$fp+1]]==$stack[$fp-3])&&(($obj.$state[$stack[$fp+1]]==EXCLUSIVE)||($obj.$state[$stack[$fp+1]]==MODIFIED)))) {
					$pc = 78
					continue
				}
				if (!($stack[$fp+2]&&$obj.$state[$stack[$fp+1]]==MODIFIED&&$obj.$tbit[$stack[$fp+1]]==0)) {
					$pc = 75
					continue
				}
				showBusOp(sprintf("CPU %d flushes a%d from its cache to memory", $obj.$cpuN, $stack[$fp-3]))
				$call(9, $obj, $stack[$fp-3])
				continue
			case 74:
				$g[53]++
				$g[59].setTxt("bus cycles: %d", $g[53])
				$pc = 75
			case 75:
				$obj.$setValues($stack[$fp+1], $stack[$fp-3], $obj.$d[$stack[$fp+1]]+$stack[$fp-4])
				$obj.$state[$stack[$fp+1]]=MODIFIED
				$obj.$stateR[$stack[$fp+1]].setTxt("M")
				if (!($stack[$fp+2])) {
					$pc = 76
					continue
				}
				$obj.$tbit[$stack[$fp+1]]=1
				$obj.$tbitR[$stack[$fp+1]].setTxt("T")
				$pc = 77
				continue
			case 76:
				$g[57].$stale[$stack[$fp-3]]=1
				$g[57].$memR[$stack[$fp-3]].setBrush($g[29])
				$pc = 77
			case 77:
				$return(2)
				continue
			case 78:
				$pc = 79
			case 79:
				if (!(1)) {
					$pc = 102
					continue
				}
				if (!(($obj.$state[$stack[$fp+1]]==INVALID)||($obj.$a[$stack[$fp+1]]!=$stack[$fp-3]))) {
					$pc = 82
					continue
				}
				$call(42, $obj, $stack[$fp-3], 0)
				continue
			case 80:
				if (!($stack[$fp+2]&&($g[61][$obj.$cpuN].$transaction==0))) {
					$pc = 81
					continue
				}
				$return(2)
				continue
			case 81:
				$pc = 82
			case 82:
				$obj.$setValues($stack[$fp+1], $stack[$fp-3], $obj.$d[$stack[$fp+1]]+$stack[$fp-4])
				if (!($obj.$state[$stack[$fp+1]]==SHARED)) {
					$pc = 98
					continue
				}
				$call(35, $obj)
				continue
			case 83:
				if (!($stack[$fp+2]&&$g[61][$obj.$cpuN].$transaction==0)) {
					$pc = 85
					continue
				}
				$call(40, $obj)
				continue
			case 84:
				$pc = 102
				continue
			case 85:
				if (!($obj.$state[$stack[$fp+1]]==INVALID)) {
					$pc = 86
					continue
				}
				$pc = 79
				continue
			case 86:
				$obj.$resetBus()
				if (!($stack[$fp+2])) {
					$pc = 87
					continue
				}
				showBusOp(sprintf("CPU %d \"writes\" to a%d to invalidate other cached copies", $obj.$cpuN, $stack[$fp-3]))
				$pc = 88
				continue
			case 87:
				showBusOp(sprintf("CPU %d writes %d to a%d in memory", $obj.$cpuN, $obj.$d[$stack[$fp+1]], $stack[$fp-3]))
				$pc = 88
			case 88:
				$g[53]++
				$g[59].setTxt("bus cycles: %d", $g[53])
				$call(5, $obj.$abus, TICKS, 0)
				continue
			case 89:
				$call(5, $obj.$dbus, TICKS, 1)
				continue
			case 90:
				$g[55].$setColour(BLUE)
				$g[54].$setColour(RED)
				if (!($stack[$fp+2]==0)) {
					$pc = 93
					continue
				}
				$call(5, $g[57].$abus, TICKS, 0)
				continue
			case 91:
				$call(5, $g[57].$dbus, TICKS, 0)
				continue
			case 92:
				$pc = 93
			case 93:
				fork(27, $obj, $stack[$fp-3], $obj.$cpuN, 1)
				$pc = 94
				if (wait(2*TICKS)) {
					return
				}
			case 94:
				if (!($stack[$fp+2]==0)) {
					$pc = 95
					continue
				}
				$g[57].$mem[$stack[$fp-3]]=$obj.$d[$stack[$fp+1]]
				$g[57].$memR[$stack[$fp-3]].setTxt("address: a%d data: %d", $stack[$fp-3], $g[57].$mem[$stack[$fp-3]])
				$g[57].$highlight($stack[$fp-3], 1)
				$obj.$state[$stack[$fp+1]]=EXCLUSIVE
				$obj.$stateR[$stack[$fp+1]].setTxt("E")
				$pc = 96
				continue
			case 95:
				$obj.$state[$stack[$fp+1]]=MODIFIED
				$obj.$stateR[$stack[$fp+1]].setTxt("M")
				$obj.$tbit[$stack[$fp+1]]=1
				$obj.$tbitR[$stack[$fp+1]].setTxt("T")
				$pc = 96
			case 96:
				$call(40, $obj)
				continue
			case 97:
				$pc = 102
				continue
			case 98:
				if (!(($obj.$state[$stack[$fp+1]]==EXCLUSIVE)||($obj.$state[$stack[$fp+1]]==MODIFIED))) {
					$pc = 100
					continue
				}
				$obj.$state[$stack[$fp+1]]=MODIFIED
				$obj.$stateR[$stack[$fp+1]].setTxt("M")
				if (!($g[61][$obj.$cpuN].$transaction==0)) {
					$pc = 99
					continue
				}
				$g[57].$stale[$stack[$fp-3]]=1
				$g[57].$memR[$stack[$fp-3]].setBrush($g[29])
				$pc = 99
			case 99:
				$g[58].setOpacity(0)
				$pc = 102
				continue
			case 100:
				$pc = 101
			case 101:
				$pc = 79
				continue
			case 102:
				$return(2)
				continue
			case 103:
				$enter(0);	// cpuButtonAction
				$obj.$resetCPUs($obj.parent.$cpuN)
				if (!($g[52]==-1)) {
					$pc = 104
					continue
				}
				$g[60][$obj.parent.$cpuN].$resetBus()
				$pc = 104
			case 104:
				$obj.parent.$buttonLock=1
				$g[60][$obj.parent.$cpuN].$reset()
				$obj.setPen($g[32])
				if (!($obj.$op==0)) {
					$pc = 106
					continue
				}
				$call(42, $g[60][$obj.parent.$cpuN], $obj.$addr, 1)
				continue
			case 105:
				$pc = 111
				continue
			case 106:
				if (!($obj.$op==1)) {
					$pc = 108
					continue
				}
				$call(71, $g[60][$obj.parent.$cpuN], $obj.$addr, 1)
				continue
			case 107:
				$pc = 110
				continue
			case 108:
				$call(71, $g[60][$obj.parent.$cpuN], $obj.$addr, -1)
				continue
			case 109:
				$pc = 110
			case 110:
				$pc = 111
			case 111:
				$obj.parent.$selected=0
				checkPoint()
				$obj.parent.$buttonLock=0
				$return(0)
				continue
			case 112:
				$enter(2);	// $eh2
				$stack[$fp+1]=0
				if (!($stack[$fp-3]&&($stack[$fp-4]&MB_LEFT))) {
					$pc = 120
					continue
				}
				$stack[$fp+1]|=REMEMBER
				if (!($obj.parent.$buttonLock)) {
					$pc = 113
					continue
				}
				$acc = $stack[$fp+1]
				$return(4)
				continue
			case 113:
				$stack[$fp+2]=0
				$pc = 114
			case 114:
				if (!($stack[$fp+2]<NCPU)) {
					$pc = 116
					continue
				}
				$g[61][$stack[$fp+2]].$resetButtons()
				$pc = 115
			case 115:
				$stack[$fp+2]++
				$pc = 114
				continue
			case 116:
				if (!($stack[$fp-4]&MB_CTRL)) {
					$pc = 117
					continue
				}
				$obj.$select()
				$pc = 119
				continue
			case 117:
				$obj.parent.$selected=$obj
				$call(124, $obj)
				continue
			case 118:
				$pc = 119
			case 119:
				$pc = 120
			case 120:
				$acc = $stack[$fp+1]
				$return(4)
				continue
			case 121:
				$enter(0);	// cpuAction
				if (!($obj.$selected&&$obj.$buttonLock==0)) {
					$pc = 123
					continue
				}
				$call(103, $obj.$selected)
				continue
			case 122:
				$pc = 123
			case 123:
				$return(0)
				continue
			case 124:
				$enter(1);	// startAction
				start()
				$stack[$fp+1]=0
				$pc = 125
			case 125:
				if (!($stack[$fp+1]<NCPU)) {
					$pc = 127
					continue
				}
				fork(121, $g[61][$stack[$fp+1]])
				$pc = 126
			case 126:
				$stack[$fp+1]++
				$pc = 125
				continue
			case 127:
				$return(0)
				continue
			case 128:
				$enter(0);	// $eh6
				if (!($stack[$fp-3]&&($stack[$fp-4]&MB_LEFT))) {
					$pc = 129
					continue
				}
				reset()
				return
			case 129:
				$acc = 0
				$return(4)
				continue
			}
		}
	}

	this.$getCurrentThread = $getCurrentThread
	this.$execute = $execute
	this.$resumeThread = $resumeThread
	this.$suspendThread = $suspendThread
	this.$switchToThread = $switchToThread
	this.$testFlag = $testFlag

}

// eof
