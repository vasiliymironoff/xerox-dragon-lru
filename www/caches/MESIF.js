// generated by VivioJS 22.02 build 0 : 14-Feb-22 14:27:43

"use strict"

function MESIF(vplayer) {

	// preload fonts
	let font = new FontFace('Open Sans', 'url("../fonts/open-sans-v18-latin-regular.woff")', {weight:400})
	font.load()
	document.fonts.add(font)
	font = new FontFace('Open Sans', 'url("../fonts/open-sans-v18-latin-700.woff")', {weight:700})
	font.load()
	document.fonts.add(font)
	font = new FontFace('Open Sans', 'url("../fonts/open-sans-v18-latin-italic.woff")', {style:'italic', weight:400})
	font.load()
	document.fonts.add(font)

	// const imports
	const ABSOLUTE = vplayer.ABSOLUTE
	const ARROW60_END = vplayer.ARROW60_END
	const ARROW60_START = vplayer.ARROW60_START
	const BLACK = vplayer.BLACK
	const BLUE = vplayer.BLUE
	const CYAN = vplayer.CYAN
	const GRAY128 = vplayer.GRAY128
	const GRAY160 = vplayer.GRAY160
	const GRAY192 = vplayer.GRAY192
	const GRAY224 = vplayer.GRAY224
	const GRAY32 = vplayer.GRAY32
	const GRAY64 = vplayer.GRAY64
	const GRAY96 = vplayer.GRAY96
	const GREEN = vplayer.GREEN
	const HLEFT = vplayer.HLEFT
	const HRIGHT = vplayer.HRIGHT
	const ITALIC = vplayer.ITALIC
	const MAGENTA = vplayer.MAGENTA
	const MB_CTRL = vplayer.MB_CTRL
	const MB_LEFT = vplayer.MB_LEFT
	const PROPAGATE = vplayer.PROPAGATE
	const RED = vplayer.RED
	const REMEMBER = vplayer.REMEMBER
	const ROUND_END = vplayer.ROUND_END
	const VBOTTOM = vplayer.VBOTTOM
	const VTOP = vplayer.VTOP
	const WHITE = vplayer.WHITE
	const YELLOW = vplayer.YELLOW

	// var imports
	var $addWaitToEventQ = vplayer.$addWaitToEventQ
	var $g = vplayer.$g
	var $terminateThread = vplayer.$terminateThread
	var debug = vplayer.debug
	var EXTENDEDGOBJ = vplayer.EXTENDEDGOBJ
	var Font = vplayer.Font
	var fork = vplayer.fork
	var getArgAsNum = vplayer.getArgAsNum
	var getLastModifiedMS = vplayer.getLastModifiedMS
	var getTick = vplayer.getTick
	var Group = vplayer.Group
	var Layer = vplayer.Layer
	var Line2 = vplayer.Line2
	var newArray = vplayer.newArray
	var Polygon = vplayer.Polygon
	var Rectangle = vplayer.Rectangle
	var Rectangle2 = vplayer.Rectangle2
	var reset = vplayer.reset
	var rgba = vplayer.rgba
	var setBgBrush = vplayer.setBgBrush
	var setTPS = vplayer.setTPS
	var setVirtualWindow = vplayer.setVirtualWindow
	var SolidBrush = vplayer.SolidBrush
	var SolidPen = vplayer.SolidPen
	var sprintf = vplayer.sprintf
	var start = vplayer.start
	var stop = vplayer.stop
	var timeToString = vplayer.timeToString
	var Txt = vplayer.Txt
	var VObj = vplayer.VObj

	// const declarations
	const W=3200
	const H=2000
	const TICKS=50
	const NCPU=5
	const NLINK=4
	const BORDER=50
	const NMEM=4
	const MEMW=150
	const MEMH=48
	const MEMTXTH=30
	const BUSW=25
	const BUSH=120
	const BUSLABELW=100
	const BUSLABELH=40
	const NCACHE=2
	const CACHEH=MEMH
	const CTXTW=0
	const CSTATEW=50
	const BB=5
	const BW=MEMW
	const BH=MEMH
	const LINKPENW=20
	const LINKOFF=60
	const LINKLABELW=100
	const LINKLABELH=30
	const CPUW=(BW+BB)*NMEM+BB
	const CPUH=BB+MEMTXTH+MEMH+BUSH+NCACHE*CACHEH+BUSH+NCPU*(BH+BB)
	const CADDRW=(CPUW-2*BB-CTXTW-CSTATEW)/2
	const CDATAW=CADDRW
	const BROADCAST=255
	const MSGH=40
	const NOP=0
	const READOP=1
	const WRITEOP=2
	const I=0
	const E=1
	const S=2
	const M=3
	const F=4
	const GETS=0
	const GETX=1
	const PIL=2
	const IACK=3
	const SACK=4
	const ACK=5
	const DACK=6
	const DATAE=7
	const DATAM=8
	const DATAF=9
	const WB=10
	const XFR=11
	const READ=12
	const CNCL=13
	const CNFL=14
	const WRINC=100

	var $thread = 0
	var $pc = 0
	var $fp = -1
	var $sp = -1
	var $acc = 0
	var $obj = 0
	var $stack = 0
	var $testFlag = 0

	function $call(pc, obj) {
		if (obj === undefined)
			obj = 0
		let l = arguments.length - 1
		for (let i = l; i >= 2; i--)
			$stack[++$sp] = arguments[i]
		$acc = obj
		$stack[++$sp] = $pc + 1
		$pc = pc
		return $acc
	}

	function $enter(n) {	// n = # local variables
		$stack[++$sp] = $obj
		$stack[++$sp] = $fp
		$fp = $sp
		$obj = $acc
		$sp += n
	}

	function $return(n) {	// n = # parameters to pop
		$sp = $fp
		$fp = $stack[$sp--]
		$obj = $stack[$sp--]
		$pc = $stack[$sp--]
		if ($pc == -1) {
			$terminateThread($thread)
			$thread = 0
			return
		}
		$sp -= n
	}

	function $suspendThread() {
		if ($thread == 0)
			return 0;
		$thread.pc = $pc
		$thread.fp = $fp
		$thread.sp = $sp
		$thread.acc = $acc
		$thread.obj = $obj
		return $thread
	}

	function $getCurrentThread() {
		return $thread
	}

	function $resumeThread(toThread) {
		$pc = toThread.pc
		$fp = toThread.fp
		$sp = toThread.sp
		$acc = toThread.acc
		$obj = toThread.obj
		$stack = toThread.stack
		$thread = toThread
	}

	function $switchToThread(toThread) {
		if ($thread == toThread) {
			$acc = toThread.acc
			return
		}
		$suspendThread()
		$resumeThread(toThread)
	}

	function wait(ticks) {
		$suspendThread()
		$addWaitToEventQ(ticks, $thread)	// -ve ticks for a realtime wait
		return 1
	}

	function SimpleButton($grp, x, y, w, h, _b0, _b1, p0, _p1, txtpen, _f1, _f2, txt) {
		Group.call(this, $grp, 0, ((0) | EXTENDEDGOBJ), x, y, 0, 0, w, h)
		this.$b0=_b0
		this.$b1=_b1
		this.$p1=_p1
		this.$f1=_f1
		this.$f2=_f2
		this.$enabled=1
		this.setPen(p0)
		this.setBrush(this.$b0)
		this.setTxtPen(txtpen)
		this.setFont(this.$f1)
		this.setTxt(txt)
		this.setRounded(4, 4)
		this.$buttonFG=new Rectangle2(this, 0, 0, 0, 0, 1, 1, w-2, h-2)
		this.$buttonFG.setRounded(4, 4)
		this.addEventHandler("eventEE", this, this.$eh0)
		this.addEventHandler("eventMB", this, this.$eh1)
	}
	SimpleButton.prototype = Object.create(Group.prototype)

	SimpleButton.prototype.$eh0 = function(enter, $1, $2) {
		this.setBrush(enter ? this.$b1 : this.$b0)
		return PROPAGATE
	}

	SimpleButton.prototype.$eh1 = function(down, $1, $2, $3) {
		if (this.$enabled) {
			this.setFont(down ? this.$f2 : this.$f1)
			this.$buttonFG.setPen(down ? this.$p1 : 0)
		}
		return PROPAGATE
	}

	function workEnd() {
		if (--$g[33]==0) {
			debug("stop tick=%d", getTick())
			stop()
		}
	}

	function CPU() {
	}
	CPU.prototype = Object.create(Group.prototype)

	CPU.prototype.$a2CPU = function(a) {
		return a/NMEM|0
	}

	CPU.prototype.$MemOp = function($parent) {
		this.parent = $parent
		VObj.call(this)
		this.$owner=-1
		this.$conflicts=0
	}
	CPU.prototype.$MemOp.prototype = Object.create(VObj.prototype)

	CPU.prototype.$Memory = function($parent, $grp) {
		this.parent = $parent
		Group.call(this, $grp, 0, ((HLEFT|VTOP) | EXTENDEDGOBJ), BB, BB+MEMTXTH, 0, 0, CPUW-2*BB, MEMH)
		this.$data=newArray(NMEM)
		this.$memR=newArray(NMEM)
		for (this.$i=0, this.$a=this.parent.$cpuN*NMEM; this.$i<NMEM; this.$i++, this.$a++) {
			this.parent = $parent
			this.$data[this.$i]=this.$a
			this.$memR[this.$i]=new Rectangle(this, 0, 0, $g[1], $g[55][this.parent.$cpuN], this.$i*CPUW/NMEM, 0, 0, 0, MEMW, MEMH, $g[1], $g[39], "a%d:%d", this.$a, this.$a)
			this.$memR[this.$i].setRounded(15, 15)
			this.parent.$memOp[this.$i]=new this.parent.$MemOp($parent)
		}
	}
	CPU.prototype.$Memory.prototype = Object.create(Group.prototype)

	CPU.prototype.$Memory.prototype.$$update = function(addr, d) {
		this.$data[addr/NCPU|0]=d
		this.$memR[addr/NCPU|0].setTxt("a%d:%d", addr, d)
	}

	CPU.prototype.$Bus = function($parent, _x, _y0, _y1, double) {
		this.parent = $parent
		VObj.call(this)
		this.$x=_x
		this.$y0=_y0
		this.$y1=_y1
		this.$bgArrow=new Line2(this.parent, 0, ABSOLUTE, double ? $g[51] : $g[50], this.$x, this.$y0, this.$x, this.$y1)
		this.$fgArrow=new Line2(this.parent, 0, ABSOLUTE, 0, this.$x, this.$y0, this.$x, this.$y1)
		this.$fgArrow.setOpacity(0)
		this.$label=new Rectangle(this.parent, 0, ABSOLUTE, $g[1], $g[17], this.$x, (this.$y0+this.$y1)/2, -BUSLABELW/2, -BUSLABELH/2, BUSLABELW, BUSLABELH, $g[1], $g[40])
		this.$label.setRounded(15, 15)
		this.$label.setOpacity(0)
	}
	CPU.prototype.$Bus.prototype = Object.create(VObj.prototype)

	CPU.prototype.$Bus.prototype.$reset = function() {
		this.$bgArrow.setOpacity(1)
		this.$fgArrow.setOpacity(0)
		this.$label.setOpacity(0)
	}

	CPU.prototype.$Cache = function($parent, $grp) {
		this.parent = $parent
		Group.call(this, $grp, 0, ((HLEFT|VTOP) | EXTENDEDGOBJ), BB, BB+MEMTXTH+MEMH+BUSH, CTXTW, 0, CPUW-2*BB-CTXTW, NCACHE*CACHEH)
		this.$state=newArray(NCACHE)
		this.$addr=newArray(NCACHE)
		this.$data=newArray(NCACHE)
		this.$xfrOwnerLock=newArray(NCACHE)
		this.$xfrOwnerMsgQ=newArray(NCACHE)
		this.$stateR=newArray(NCACHE)
		this.$addrR=newArray(NCACHE)
		this.$dataR=newArray(NCACHE)
		this.$xfrOwnerLockR=newArray(NCACHE)
		for (this.$i=0; this.$i<NCACHE; this.$i++) {
			this.parent = $parent
			this.$state[this.$i]=I
			this.$addr[this.$i]=0
			this.$data[this.$i]=0
			this.$xfrOwnerLock[this.$i]=0
			this.$xfrOwnerMsgQ[this.$i]=new MsgQ()
			this.$stateR[this.$i]=new Rectangle(this, 0, 0, $g[1], $g[17], CTXTW, this.$i*CACHEH, 0, 0, CSTATEW, CACHEH, $g[1], $g[39], "I")
			this.$addrR[this.$i]=new Rectangle(this, 0, 0, $g[1], $g[17], CTXTW+CSTATEW, this.$i*CACHEH, 0, 0, CADDRW, CACHEH, $g[1], $g[39], "a0")
			this.$dataR[this.$i]=new Rectangle(this, 0, 0, $g[1], $g[17], CTXTW+CSTATEW+CADDRW, this.$i*CACHEH, 0, 0, CDATAW, CACHEH, $g[1], $g[39], "0")
			this.$xfrOwnerLockR[this.$i]=new Rectangle(this, 0, 0, $g[49], 0, CTXTW, this.$i*CACHEH, 0, 0, CSTATEW+CADDRW+CDATAW, CACHEH)
			this.$stateR[this.$i].setRounded(15, 15)
			this.$addrR[this.$i].setRounded(15, 15)
			this.$dataR[this.$i].setRounded(15, 15)
			this.$xfrOwnerLockR[this.$i].setRounded(15, 15)
			this.$xfrOwnerLockR[this.$i].setOpacity(0)
		}
	}
	CPU.prototype.$Cache.prototype = Object.create(Group.prototype)

	CPU.prototype.$Cache.prototype.$setState = function(a, s) {
		let set=a&1
		this.$state[set]=s
		this.$stateR[set].setTxt($g[31][s])
	}

	CPU.prototype.$Cache.prototype.$$update = function(s, a, d) {
		let set=a&1
		this.$state[set]=s
		this.$addr[set]=a
		this.$data[set]=d
		this.$stateR[set].setTxt($g[31][s])
		this.$addrR[set].setTxt("a%d", a)
		this.$dataR[set].setTxt("%d", d)
	}

	CPU.prototype.$Cache.prototype.$hit = function(a) {
		let set=a&1
		return (this.$state[set]!=I)&&(this.$addr[set]==a)
	}

	CPU.prototype.$Cache.prototype.$writeHit = function(a) {
		let set=a&1
		debug("write hit a=%d set=%d", a, set)
		return ((this.$state[set]==M)||(this.$state[set]==E))&&(this.$addr[set]==a)
	}

	CPU.prototype.$RWButton = function($parent, $grp, _x, _y, _addr) {
		this.parent = $parent
		Group.call(this, $grp, 0, ((0) | EXTENDEDGOBJ), _x, _y, 0, 0, BW, BH)
		this.$a=_addr
		this.$rw=0
		this.setBrush($g[55][this.parent.$a2CPU(this.$a)])
		this.setPen($g[1])
		this.setFont($g[39])
		this.setTxt("a%d", this.$a)
		this.setRounded(15, 15)
		this.$readB=new Polygon(this, 0, HLEFT|VTOP|ABSOLUTE, $g[3], $g[55][this.parent.$a2CPU(this.$a)], 0, 0, 0, 0, BW, 0, 0, BH)
		this.$readB.setPen($g[1])
		this.$readB.setFont($g[40])
		this.$readB.setTxt("R")
		this.$readB.setOpacity(0)
		this.$readB.setTxtOff(4, 1)
		this.$writeB=new Polygon(this, 0, HRIGHT|VBOTTOM|ABSOLUTE, $g[3], $g[55][this.parent.$a2CPU(this.$a)], 0, 0, 0, BH, BW, 0, BW, BH)
		this.$writeB.setPen($g[1])
		this.$writeB.setFont($g[40])
		this.$writeB.setTxt("W")
		this.$writeB.setOpacity(0)
		this.$writeB.setTxtOff(-4, 0)
		this.addEventHandler("eventEE", this, this.$eh2)
		this.$readB.addEventHandler("eventEE", this, this.$eh3)
		this.$writeB.addEventHandler("eventEE", this, this.$eh4)
		this.$readB.addEventHandler("eventMB", this, 28)
		this.$writeB.addEventHandler("eventMB", this, 33)
	}
	CPU.prototype.$RWButton.prototype = Object.create(Group.prototype)

	CPU.prototype.$RWButton.prototype.$select = function(_rw) {
		this.$rw=_rw
		if (this.parent.$selected==this) {
			this.setPen($g[1])
			this.setTxt("a%d", this.$a)
			this.parent.$selected=0
		} else {
			if (this.parent.$selected) {
				this.parent.$selected.setPen($g[1])
				this.parent.$selected.setTxt("a%d", this.$a)
			}
			this.parent.$selected=this
			this.setPen($g[48])
			this.setTxt("%s a%d", this.$rw ? "W" : "R", this.$a)
			this.$readB.setOpacity(0)
			this.$writeB.setOpacity(0)
		}
	}

	CPU.prototype.$RWButton.prototype.$eh2 = function(enter, $1, $2) {
		if (this.parent.$buttonsLock==0) {
			this.$readB.setOpacity(enter ? 1 : 0)
			this.$writeB.setOpacity(enter ? 1 : 0)
			this.setBrush(enter ? 0 : $g[55][this.parent.$a2CPU(this.$a)])
			if (enter==0)
			this.setTxt("a%d", this.$a)
		}
	}

	CPU.prototype.$RWButton.prototype.$eh3 = function(enter, $1, $2) {
		this.$readB.setBrush(enter ? $g[56][this.parent.$a2CPU(this.$a)] : $g[55][this.parent.$a2CPU(this.$a)])
	}

	CPU.prototype.$RWButton.prototype.$eh4 = function(enter, $1, $2) {
		this.$writeB.setBrush(enter ? $g[56][this.parent.$a2CPU(this.$a)] : $g[55][this.parent.$a2CPU(this.$a)])
	}

	CPU.prototype.$writeFinish = function(addr, end) {
		debug("writeFinish")
		let set=this.$opAddr&1
		this.$cache.$$update(M, addr, this.$opWrval)
		this.$op=NOP
		this.$selected=0
		this.$buttonsLock=0
		if (end)
		workEnd()
	}

	function Link(cpuA, linkA, cpuB, linkB) {
		VObj.call(this)
		this.$dstCPU=cpuB
		this.$x0=$g[58][cpuA].$x
		this.$y0=$g[58][cpuA].$y
		this.$x1=$g[58][cpuB].$x
		this.$y1=$g[58][cpuB].$y
		this.$dy=(this.$y0==this.$y1) ? (cpuA<cpuB ? -LINKOFF : LINKOFF) : 0
		this.$dx=(this.$x0==this.$x1) ? (cpuA<cpuB ? LINKOFF : -LINKOFF) : 0
		if (linkA==0) {
			this.$x0+=CPUW/2+this.$dx
		} else
		if (linkA==1) {
			this.$x0+=CPUW+this.$dx
			this.$y0+=CPUH/2+this.$dy
		} else
		if (linkA==2) {
			this.$x0+=CPUW/2+this.$dx
			this.$y0+=CPUH+this.$dy
		} else {
			this.$y0+=CPUH/2+this.$dy
		}
		if (linkB==0) {
			this.$x1+=CPUW/2+this.$dx
		} else
		if (linkB==1) {
			this.$x1+=CPUW+this.$dx
			this.$y1+=CPUH/2+this.$dy
		} else
		if (linkB==2) {
			this.$x1+=CPUW/2+this.$dx
			this.$y1+=CPUH+this.$dy
		} else {
			this.$y1+=CPUH/2+this.$dy
		}
		this.$tx=new Line2($g[0], 0, ABSOLUTE, $g[46], this.$x0, this.$y0, this.$x1, this.$y1)
		this.$lock=0
	}
	Link.prototype = Object.create(VObj.prototype)

	function Msg($grp) {
		Group.call(this, $grp, $g[38], ((0) | EXTENDEDGOBJ), 0, 0, 0, 0, 0, 0)
		this.$srcCPU
		this.$dstCPU
		this.$op
		this.$data=newArray(2)
		this.$next
		this.$srcR=new Rectangle(this, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, $g[1], $g[44])
		this.$dstR=new Rectangle(this, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, $g[1], $g[44])
		this.setPen($g[1])
		this.setFont($g[44])
		this.setRounded(15, 15)
	}
	Msg.prototype = Object.create(Group.prototype)

	function MsgQ() {
		VObj.call(this)
		this.$head=0
		this.$tail=0
	}
	MsgQ.prototype = Object.create(VObj.prototype)

	MsgQ.prototype.$push = function(msg) {
		msg.$next=0
		if (this.$head) {
			this.$tail.$next=msg
			this.$tail=msg
		} else {
			this.$head=this.$tail=msg
		}
	}

	MsgQ.prototype.$pop = function() {
		let r=this.$head
		this.$head=this.$head.$next
		if (this.$head==0)
		this.$tail=0
		r.$next=0
		return r
	}

	function newMsg(srcCPU, dstCPU, op, d0) {
		let msg
		if ($g[37]) {
			msg=$g[37]
			$g[37]=$g[37].$next
		} else {
			msg=new Msg($g[0])
		}
		msg.$srcCPU=srcCPU
		msg.$dstCPU=dstCPU
		msg.$op=op
		msg.$data[0]=d0
		msg.$next=0
		return msg
	}

	function newMsg2(srcCPU, dstCPU, op, d0, d1) {
		let msg=newMsg(srcCPU, dstCPU, op, d0)
		msg.$data[1]=d1
		return msg
	}

	function newMsg3(srcCPU, dstCPU, op, d0, d1, d2) {
		let msg=newMsg2(srcCPU, dstCPU, op, d0, d1)
		msg.$data[2]=d2
		return msg
	}

	function freeMsg(msg) {
		msg.$next=$g[37]
		$g[37]=msg
	}

	function connect(cpuA, linkA, cpuB, linkB) {
		$g[58][cpuA].$txLink[linkA]=$g[58][cpuB].$rxLink[linkB]=new Link(cpuA, linkA, cpuB, linkB)
		$g[58][cpuA].$rxLink[linkA]=$g[58][cpuB].$txLink[linkB]=new Link(cpuB, linkB, cpuA, linkA)
		$g[58][cpuA].$linkR[linkA].setOpacity(1)
		$g[58][cpuB].$linkR[linkB].setOpacity(1)
	}

	function $execute(thread) {

		$switchToThread(thread);

		while (1) {
			switch ($pc) {
			case -1:
				return;		// catch thread termination
			case 0:
				$enter(0)	// start with a function call
				$g[1]=new SolidPen(0, 0, BLACK)
				$g[2]=new SolidPen(0, 0, WHITE)
				$g[3]=new SolidPen(0, 0, RED)
				$g[4]=new SolidPen(0, 0, GREEN)
				$g[5]=new SolidPen(0, 0, BLUE)
				$g[6]=new SolidPen(0, 0, YELLOW)
				$g[7]=new SolidPen(0, 0, MAGENTA)
				$g[8]=new SolidPen(0, 0, CYAN)
				$g[9]=new SolidPen(0, 0, GRAY32)
				$g[10]=new SolidPen(0, 0, GRAY64)
				$g[11]=new SolidPen(0, 0, GRAY96)
				$g[12]=new SolidPen(0, 0, GRAY128)
				$g[13]=new SolidPen(0, 0, GRAY160)
				$g[14]=new SolidPen(0, 0, GRAY192)
				$g[15]=new SolidPen(0, 0, GRAY224)
				$g[16]=new SolidBrush(BLACK)
				$g[17]=new SolidBrush(WHITE)
				$g[18]=new SolidBrush(RED)
				$g[19]=new SolidBrush(GREEN)
				$g[20]=new SolidBrush(BLUE)
				$g[21]=new SolidBrush(YELLOW)
				$g[22]=new SolidBrush(MAGENTA)
				$g[23]=new SolidBrush(CYAN)
				$g[24]=new SolidBrush(GRAY32)
				$g[25]=new SolidBrush(GRAY64)
				$g[26]=new SolidBrush(GRAY96)
				$g[27]=new SolidBrush(GRAY128)
				$g[28]=new SolidBrush(GRAY160)
				$g[29]=new SolidBrush(GRAY192)
				$g[30]=new SolidBrush(GRAY224)
				$g[31]=["I", "E", "S", "M", "F"]
				$g[32]=["GETS", "GETX", "PIL", "IACK", "SACK", "ACK", "DACK", "DATAE", "DATAM", "DATAF", "WB", "XFR", "READ", "CNCL", "CNFL"]
				setVirtualWindow(0, 0, W, H, 1)
				setBgBrush($g[30])
				setTPS(TICKS)
				$g[33]=0
				$g[34]=WRINC
				$g[37]=0
				$g[38]=new Layer(10)
				$g[39]=new Font("Open Sans", 36)
				$g[40]=new Font("Open Sans", 32)
				$g[41]=new Font("Open Sans", 26, ITALIC)
				$g[42]=new Font("Open Sans", 35, ITALIC)
				$g[43]=new Font("Open Sans", 30, ITALIC)
				$g[44]=new Font("Open Sans", 35)
				$g[45]=new Font("Open Sans", 80, 0)
				$g[46]=new SolidPen(0, LINKPENW, GRAY128, ARROW60_END)
				$g[47]=new SolidPen(0, 6, rgba(0, 0.59999999999999998, 0), ROUND_END)
				$g[48]=new SolidPen(0, 4, rgba(1, 0.55000000000000004, 0), ROUND_END)
				$g[49]=new SolidPen(0, 4, rgba(1, 0, 0), ROUND_END)
				$g[50]=new SolidPen(0, BUSW, GRAY224, ARROW60_END)
				$g[51]=new SolidPen(0, BUSW, GRAY224, ARROW60_START|ARROW60_END)
				$g[52]=new SolidPen(0, BUSW, RED, ARROW60_END)
				$g[53]=new SolidPen(0, BUSW, BLUE, ARROW60_END)
				$g[54]=new SolidBrush(rgba(0, 0.56000000000000005, 0.16))
				$g[55]=newArray(5)
				$g[56]=newArray(5)
				$g[55][0]=new SolidBrush(rgba(1, 1, 0.59999999999999998))
				$g[55][1]=new SolidBrush(rgba(1, 0.69999999999999996, 0.69999999999999996))
				$g[55][2]=new SolidBrush(rgba(0.69999999999999996, 1, 0.69999999999999996))
				$g[55][3]=new SolidBrush(rgba(0.59999999999999998, 0.69999999999999996, 1))
				$g[55][4]=new SolidBrush(rgba(1, 0.80000000000000004, 0.20000000000000001))
				$g[56][0]=new SolidBrush(rgba(0.80000000000000004, 0.80000000000000004, 0.40000000000000002))
				$g[56][1]=new SolidBrush(rgba(0.80000000000000004, 0.5, 0.5))
				$g[56][2]=new SolidBrush(rgba(0.5, 0.80000000000000004, 0.5))
				$g[56][3]=new SolidBrush(rgba(0.40000000000000002, 0.5, 0.80000000000000004))
				$g[56][4]=new SolidBrush(rgba(0.80000000000000004, 0.59999999999999998, 0))
				$g[57]=new Rectangle2($g[0], 0, 0, 0, $g[54], 10, 10, W/2, 100, $g[2], $g[45], "MESIF Protocol")
				$g[57].setRounded(5, 5)
				$g[57].setTxtOff(0, 2)
				$g[57].setPt(1, $g[57].getTxtW()+40, 100)
				new Txt($g[0], 0, HRIGHT|VBOTTOM, W-BORDER, H-10, $g[14], $g[43], timeToString(getLastModifiedMS(), "last modified %e-%b-%y"))
				$g[58]=newArray(NCPU)
				$g[35]=(W-3*CPUW-2*BORDER)/2
				$call(8, new CPU(), BORDER+CPUW+$g[35], 100, 0)
				continue
			case 1:
				$g[58][0] = $acc
				$call(8, new CPU(), BORDER+2*CPUW+2*$g[35], 100, 1)
				continue
			case 2:
				$g[58][1] = $acc
				$call(8, new CPU(), BORDER, H-100-CPUH, 2)
				continue
			case 3:
				$g[58][2] = $acc
				$call(8, new CPU(), BORDER+CPUW+$g[35], H-100-CPUH, 3)
				continue
			case 4:
				$g[58][3] = $acc
				$call(8, new CPU(), BORDER+2*CPUW+2*$g[35], H-100-CPUH, 4)
				continue
			case 5:
				$g[58][4] = $acc
				connect(0, 1, 1, 3)
				connect(0, 2, 3, 0)
				connect(1, 2, 4, 0)
				connect(3, 1, 4, 3)
				connect(2, 1, 3, 3)
				$g[59]=newArray(NCPU, NCPU)
				$g[59][0][0]=-1
				$g[59][0][1]=1
				$g[59][0][2]=3
				$g[59][0][3]=3
				$g[59][0][4]=1
				$g[59][1][0]=0
				$g[59][1][1]=-1
				$g[59][1][2]=4
				$g[59][1][3]=0
				$g[59][1][4]=4
				$g[59][2][0]=3
				$g[59][2][1]=3
				$g[59][2][2]=-1
				$g[59][2][3]=3
				$g[59][2][4]=3
				$g[59][3][0]=0
				$g[59][3][1]=4
				$g[59][3][2]=2
				$g[59][3][3]=-1
				$g[59][3][4]=4
				$g[59][4][0]=1
				$g[59][4][1]=1
				$g[59][4][2]=3
				$g[59][4][3]=3
				$g[59][4][4]=-1
				$g[60]=new SimpleButton($g[0], BORDER, H-75, 160, 60, $g[30], $g[29], $g[1], $g[1], $g[1], $g[39], $g[40], "Reset")
				$g[60].addEventHandler("eventMB", $obj, 181)
				if (!(getArgAsNum("selfTest", 1))) {
					$pc = 7
					continue
				}
				debug("selfTest")
				fork(73, $g[58][2], 2)
				fork(73, $g[58][3], 2)
				$call(73, $g[58][4], 2)
				continue
			case 6:
				debug("FINISHED tick=%d", getTick())
				$pc = 7
			case 7:
				$return(0)
				continue
			case 8:
				$enter(29);	// CPU
				Group.call($obj, $g[0], 0, ((HLEFT|VTOP) | EXTENDEDGOBJ), $stack[$fp-3], $stack[$fp-4], 0, 0, CPUW, CPUH)
				$obj.$x=$stack[$fp-3]
				$obj.$y=$stack[$fp-4]
				$obj.$cpuN=$stack[$fp-5]
				$obj.$opLock=0
				$obj.$op=NOP
				$obj.$opAddr=-1
				$obj.$opFlags=0
				$obj.$opWrval=0
				$obj.$opReplyCnt=0
				$obj.$opFormerOwner=-1
				$obj.$rwButton=newArray(NCPU*NMEM)
				$obj.$buttonsLock=0
				$obj.$selected=0
				$obj.$txLink=newArray(NLINK)
				$obj.$rxLink=newArray(NLINK)
				$obj.$i=0
				$pc = 9
			case 9:
				if (!($obj.$i<NLINK)) {
					$pc = 11
					continue
				}
				$obj.$txLink[$obj.$i]=$obj.$rxLink[$obj.$i]=0
				$pc = 10
			case 10:
				$obj.$i++
				$pc = 9
				continue
			case 11:
				$obj.$msgQ=new MsgQ()
				$obj.$memOp=newArray(NMEM)
				$obj.$i=0
				$pc = 12
			case 12:
				if (!($obj.$i<NMEM)) {
					$pc = 14
					continue
				}
				$obj.$memOp[$obj.$i]=new $obj.$MemOp($obj)
				$pc = 13
			case 13:
				$obj.$i++
				$pc = 12
				continue
			case 14:
				$obj.setPen($g[1])
				$obj.setBrush($g[29])
				$obj.setRounded(15, 15)
				$obj.setFont($g[39])
				$obj.setTxtPen($g[3])
				$obj.setTxtOff(0, -60)
				$obj.setTxt("CPU %d", $obj.$cpuN)
				$obj.$mem=new $obj.$Memory($obj, $obj)
				$obj.$memABus=new $obj.$Bus($obj, CPUW/4, BB+MEMTXTH+MEMH+BUSH, BB+MEMTXTH+MEMH, 0)
				$obj.$memDBus=new $obj.$Bus($obj, 3*CPUW/4, BB+MEMTXTH+MEMH+BUSH, BB+MEMTXTH+MEMH, 1)
				$obj.$cache=new $obj.$Cache($obj, $obj)
				$obj.$cpuABus=new $obj.$Bus($obj, CPUW/4, BB+MEMTXTH+MEMH+BUSH+NCACHE*CACHEH+BUSH, BB+MEMTXTH+MEMH+BUSH+NCACHE*CACHEH, 0)
				$obj.$cpuDBus=new $obj.$Bus($obj, 3*CPUW/4, BB+MEMTXTH+MEMH+BUSH+NCACHE*CACHEH+BUSH, BB+MEMTXTH+MEMH+BUSH+NCACHE*CACHEH, 1)
				$obj.$linkR=[new Rectangle($obj, 0, 0, 0, 0, CPUW/2, -20, -LINKLABELW/2, -LINKLABELH/2, LINKLABELW, LINKLABELH, $g[1], $g[42], "L0"), new Rectangle($obj, 0, 0, 0, 0, CPUW+40, CPUH/2, -LINKLABELW/2, -LINKLABELH/2, LINKLABELW, LINKLABELH, $g[1], $g[42], "L1"), new Rectangle($obj, 0, 0, 0, 0, CPUW/2, CPUH+20, -LINKLABELW/2, -LINKLABELH/2, LINKLABELW, LINKLABELH, $g[1], $g[42], "L2"), new Rectangle($obj, 0, 0, 0, 0, -40, CPUH/2, -LINKLABELW/2, -LINKLABELH/2, LINKLABELW, LINKLABELH, $g[1], $g[42], "L3")]
				$obj.$i=0
				$pc = 15
			case 15:
				if (!($obj.$i<4)) {
					$pc = 17
					continue
				}
				$obj.$linkR[$obj.$i].setOpacity(0)
				$pc = 16
			case 16:
				$obj.$i++
				$pc = 15
				continue
			case 17:
				new Txt($obj, 0, HLEFT, BB, BB+MEMTXTH/2, $g[11], $g[41], "memory")
				new Txt($obj, 0, HLEFT, BB, BB+MEMTXTH+MEMH+BUSH-20, $g[11], $g[41], "cache")
				new Txt($obj, 0, HLEFT, BB, BB+MEMTXTH+MEMH+BUSH+NCACHE*CACHEH+BUSH-20, $g[11], $g[41], "CPU buttons")
				$obj.$i=0, $obj.$yy=BB+MEMTXTH+MEMH+BUSH+NCACHE*CACHEH+BUSH
				$pc = 18
			case 18:
				if (!($obj.$i<NCPU)) {
					$pc = 23
					continue
				}
				$obj.$j=0, $obj.$xx=BB
				$pc = 19
			case 19:
				if (!($obj.$j<NMEM)) {
					$pc = 21
					continue
				}
				$obj.$rwButton[$obj.$i*NMEM+$obj.$j]=new $obj.$RWButton($obj, $obj, $obj.$xx, $obj.$yy, $obj.$i*NMEM+$obj.$j)
				$pc = 20
			case 20:
				$obj.$j++, $obj.$xx+=BW+BB
				$pc = 19
				continue
			case 21:
				$pc = 22
			case 22:
				$obj.$i++, $obj.$yy+=BH+BB
				$pc = 18
				continue
			case 23:
				fork(100, $obj)
				$return(3)
				continue
			case 24:
				$enter(0);	// moveUp
				$obj.$label.setTxt($stack[$fp-4])
				$obj.$fgArrow.setPen($stack[$fp-3])
				$obj.$fgArrow.setPt(0, 0, 0)
				$obj.$fgArrow.setPt(1, 0, 0)
				$obj.$label.setOpacity(1, TICKS, 0)
				$obj.$fgArrow.setOpacity(1, TICKS/4, 0)
				$obj.$fgArrow.setPt(1, 0, $obj.$y1-$obj.$y0, TICKS, 0)
				$pc = 25
				if ($obj.$bgArrow.setOpacity(0, TICKS, $stack[$fp-5])) {
					return
				}
			case 25:
				$return(3)
				continue
			case 26:
				$enter(0);	// moveDown
				$obj.$label.setTxt($stack[$fp-4])
				$obj.$fgArrow.setPen($stack[$fp-3])
				$obj.$fgArrow.setPt(0, 0, $obj.$y1-$obj.$y0)
				$obj.$fgArrow.setPt(1, 0, $obj.$y1-$obj.$y0)
				$obj.$label.setOpacity(1, TICKS, 0)
				$obj.$fgArrow.setOpacity(1, TICKS/4, 0)
				$obj.$fgArrow.setPt(1, 0, 0, TICKS, 0)
				$pc = 27
				if ($obj.$bgArrow.setOpacity(0, TICKS, $stack[$fp-5])) {
					return
				}
			case 27:
				$return(3)
				continue
			case 28:
				$enter(1);	// $eh5
				$stack[$fp+1]=0
				if (!($stack[$fp-3]&&$stack[$fp-4]&MB_LEFT)) {
					$pc = 32
					continue
				}
				$stack[$fp+1]|=REMEMBER
				if (!($obj.parent.$op!=NOP)) {
					$pc = 29
					continue
				}
				$acc = $stack[$fp+1]
				$return(4)
				continue
			case 29:
				$obj.$select(0)
				if (!(($stack[$fp-4]&MB_CTRL)==0)) {
					$pc = 31
					continue
				}
				$call(177, $obj)
				continue
			case 30:
				$pc = 31
			case 31:
				$pc = 32
			case 32:
				$acc = $stack[$fp+1]
				$return(4)
				continue
			case 33:
				$enter(1);	// $eh6
				$stack[$fp+1]=0
				if (!($stack[$fp-3]&&$stack[$fp-4]&MB_LEFT)) {
					$pc = 37
					continue
				}
				$stack[$fp+1]|=REMEMBER
				if (!($obj.parent.$op!=NOP)) {
					$pc = 34
					continue
				}
				$acc = $stack[$fp+1]
				$return(4)
				continue
			case 34:
				$obj.$select(1)
				if (!(($stack[$fp-4]&MB_CTRL)==0)) {
					$pc = 36
					continue
				}
				$call(177, $obj)
				continue
			case 35:
				$pc = 36
			case 36:
				$pc = 37
			case 37:
				$acc = $stack[$fp+1]
				$return(4)
				continue
			case 38:
				$enter(6);	// sendMsg
				if (!($stack[$fp-3]==$obj.$cpuN)) {
					$pc = 39
					continue
				}
				$obj.$msgQ.$push($stack[$fp-4])
				$return(2)
				continue
			case 39:
				$stack[$fp+1]=$g[59][$obj.$cpuN][$stack[$fp-3]]
				$stack[$fp+2]=0
				$stack[$fp+3]=0
				$pc = 40
			case 40:
				if (!($stack[$fp+3]<NLINK)) {
					$pc = 43
					continue
				}
				if (!($obj.$txLink[$stack[$fp+3]].$dstCPU==$stack[$fp+1])) {
					$pc = 41
					continue
				}
				$stack[$fp+2]=$obj.$txLink[$stack[$fp+3]]
				$pc = 43
				continue
			case 41:
				$pc = 42
			case 42:
				$stack[$fp+3]++
				$pc = 40
				continue
			case 43:
				$pc = 44
			case 44:
				if (!($stack[$fp+2].$lock==1)) {
					$pc = 46
					continue
				}
				$pc = 45
				if (wait(1)) {
					return
				}
			case 45:
				$pc = 44
				continue
			case 46:
				$stack[$fp+2].$lock=1
				$stack[$fp+4]=""
				if (!($stack[$fp-4].$op<=DACK)) {
					$pc = 47
					continue
				}
				$stack[$fp-4].setTxt("%s a%d", $g[32][$stack[$fp-4].$op], $stack[$fp-4].$data[0])
				$pc = 65
				continue
			case 47:
				if (!($stack[$fp-4].$op<=XFR)) {
					$pc = 48
					continue
				}
				$stack[$fp-4].setTxt("%s a%d %d", $g[32][$stack[$fp-4].$op], $stack[$fp-4].$data[0], $stack[$fp-4].$data[1])
				$pc = 64
				continue
			case 48:
				if (!($stack[$fp-4].$op==READ)) {
					$pc = 54
					continue
				}
				$stack[$fp+4]=sprintf("READ a%d", $stack[$fp-4].$data[0])
				if (!($stack[$fp-4].$data[1])) {
					$pc = 53
					continue
				}
				$stack[$fp+4]+=" ("
				$stack[$fp+5]=0
				$stack[$fp+3]=0
				$pc = 49
			case 49:
				if (!($stack[$fp+3]<NCPU)) {
					$pc = 52
					continue
				}
				if (!($stack[$fp-4].$data[1]&(1<<$stack[$fp+3]))) {
					$pc = 50
					continue
				}
				$stack[$fp+4]+=sprintf("%s%d", $stack[$fp+5] ? "," : "", $stack[$fp+3])
				$stack[$fp+5]=1
				$pc = 50
			case 50:
				$pc = 51
			case 51:
				$stack[$fp+3]++
				$pc = 49
				continue
			case 52:
				$stack[$fp+4]+=")"
				$pc = 53
			case 53:
				$stack[$fp-4].setTxt($stack[$fp+4])
				$pc = 63
				continue
			case 54:
				if (!($stack[$fp-4].$op==CNCL)) {
					$pc = 60
					continue
				}
				$stack[$fp+4]=sprintf("CNCL a%d %d", $stack[$fp-4].$data[0], $stack[$fp-4].$data[1])
				if (!($stack[$fp-4].$data[2])) {
					$pc = 59
					continue
				}
				$stack[$fp+4]+=" ("
				$stack[$fp+5]=0
				$stack[$fp+3]=0
				$pc = 55
			case 55:
				if (!($stack[$fp+3]<NCPU)) {
					$pc = 58
					continue
				}
				if (!($stack[$fp-4].$data[2]&(1<<$stack[$fp+3]))) {
					$pc = 56
					continue
				}
				$stack[$fp+4]+=sprintf("%s%d", $stack[$fp+5] ? "," : "", $stack[$fp+3])
				$stack[$fp+5]=1
				$pc = 56
			case 56:
				$pc = 57
			case 57:
				$stack[$fp+3]++
				$pc = 55
				continue
			case 58:
				$stack[$fp+4]+=")"
				$pc = 59
			case 59:
				$stack[$fp-4].setTxt($stack[$fp+4])
				$pc = 62
				continue
			case 60:
				if (!($stack[$fp-4].$op==CNFL)) {
					$pc = 61
					continue
				}
				$stack[$fp-4].setTxt("CNFL")
				$pc = 61
			case 61:
				$pc = 62
			case 62:
				$pc = 63
			case 63:
				$pc = 64
			case 64:
				$pc = 65
			case 65:
				$stack[$fp-4].setOpacity(1)
				$stack[$fp+6]=$stack[$fp-4].getTxtW()+20
				$stack[$fp-4].setPt(0, -$stack[$fp+6]/2, -MSGH/2)
				$stack[$fp-4].setPt(1, $stack[$fp+6]/2, MSGH/2)
				$stack[$fp-4].$srcR.setPt(0, -$stack[$fp+6]/2, -MSGH/2)
				$stack[$fp-4].$srcR.setPt(1, 0, MSGH/2)
				$stack[$fp-4].$srcR.setBrush($stack[$fp-4].$srcCPU==BROADCAST ? $g[17] : $g[55][$stack[$fp-4].$srcCPU])
				$stack[$fp-4].$dstR.setPt(0, 0, -MSGH/2)
				$stack[$fp-4].$dstR.setPt(1, $stack[$fp+6]/2, MSGH/2)
				$stack[$fp-4].$dstR.setBrush($stack[$fp-4].$dstCPU==BROADCAST ? $g[17] : $g[55][$stack[$fp-4].$dstCPU])
				$stack[$fp-4].setPos($stack[$fp+2].$x0, $stack[$fp+2].$y0)
				$pc = 66
				if ($stack[$fp-4].setPos($stack[$fp+2].$x1, $stack[$fp+2].$y1, TICKS, 1)) {
					return
				}
			case 66:
				$g[58][$stack[$fp+1]].$msgQ.$push($stack[$fp-4])
				$stack[$fp+2].$lock=0
				$return(2)
				continue
			case 67:
				$enter(1);	// broadcastMsg
				$obj.$opReplyCnt=0
				$call(38, $obj, $obj.$cpuN, newMsg($obj.$cpuN, $obj.$cpuN, $stack[$fp-3], $stack[$fp-4]))
				continue
			case 68:
				$stack[$fp+1]=0
				$pc = 69
			case 69:
				if (!($stack[$fp+1]<NLINK)) {
					$pc = 72
					continue
				}
				if (!($obj.$txLink[$stack[$fp+1]])) {
					$pc = 70
					continue
				}
				fork(38, $obj, $obj.$txLink[$stack[$fp+1]].$dstCPU, newMsg($obj.$cpuN, BROADCAST, $stack[$fp-3], $stack[$fp-4]))
				$pc = 70
			case 70:
				$pc = 71
			case 71:
				$stack[$fp+1]++
				$pc = 69
				continue
			case 72:
				$return(2)
				continue
			case 73:
				$enter(0);	// read
				debug("read: cpu=%d addr=%d", $obj.$cpuN, $stack[$fp-3])
				$obj.$cpuABus.$reset()
				$obj.$cpuDBus.$reset()
				$obj.$buttonsLock=1
				$obj.$rwButton[$stack[$fp-3]].setPen($g[47])
				$g[33]++
				$obj.$op=READOP
				$obj.$opAddr=$stack[$fp-3]
				$obj.$opFlags=0
				start()
				$call(24, $obj.$cpuABus, $g[52], sprintf("a%d", $stack[$fp-3]), 1)
				continue
			case 74:
				if (!($obj.$cache.$hit($stack[$fp-3]))) {
					$pc = 76
					continue
				}
				$call(79, $obj, $stack[$fp-3], $obj.$cache.$data[$stack[$fp-3]&1], 1)
				continue
			case 75:
				$pc = 78
				continue
			case 76:
				$call(67, $obj, GETS, $stack[$fp-3])
				continue
			case 77:
				$pc = 78
			case 78:
				$return(1)
				continue
			case 79:
				$enter(0);	// readFinish
				$call(26, $obj.$cpuDBus, $g[53], sprintf("%d", $stack[$fp-4]), 1)
				continue
			case 80:
				$obj.$op=NOP
				$obj.$selected=0
				$obj.$buttonsLock=0
				$obj.$rwButton[$stack[$fp-3]].setPen($g[1])
				if (!($stack[$fp-5])) {
					$pc = 81
					continue
				}
				workEnd()
				$pc = 81
			case 81:
				$return(3)
				continue
			case 82:
				$enter(0);	// write
				debug("write: eventMB cpu=%d addr=%d", $obj.$cpuN, $stack[$fp-3])
				$obj.$cpuABus.$reset()
				$obj.$cpuDBus.$reset()
				$obj.$buttonsLock=1
				$g[33]++
				$obj.$op=WRITEOP
				$obj.$opAddr=$stack[$fp-3]
				$obj.$opFlags=0
				start()
				$call(24, $obj.$cpuABus, $g[52], sprintf("a%d", $stack[$fp-3]), 0)
				continue
			case 83:
				$obj.$opWrval=$g[34]+$stack[$fp-3]
				$g[34]+=WRINC
				$call(24, $obj.$cpuDBus, $g[53], sprintf("%d", $obj.$opWrval), 1)
				continue
			case 84:
				if (!($obj.$cache.$writeHit($stack[$fp-3]))) {
					$pc = 85
					continue
				}
				$obj.$writeFinish($stack[$fp-3], 1)
				$pc = 87
				continue
			case 85:
				$call(67, $obj, GETX, $stack[$fp-3])
				continue
			case 86:
				$pc = 87
			case 87:
				$return(1)
				continue
			case 88:
				$enter(0);	// startRW
				if (!($obj.$selected&&$obj.$op==NOP)) {
					$pc = 93
					continue
				}
				if (!($obj.$selected.$rw==0)) {
					$pc = 90
					continue
				}
				$call(73, $obj, $obj.$selected.$a)
				continue
			case 89:
				$pc = 92
				continue
			case 90:
				$call(82, $obj, $obj.$selected.$a)
				continue
			case 91:
				$pc = 92
			case 92:
				$pc = 93
			case 93:
				$return(0)
				continue
			case 94:
				$enter(0);	// doRead
				$call(73, $obj, $stack[$fp-3])
				continue
			case 95:
				if (!($stack[$fp-4])) {
					$pc = 99
					continue
				}
				$pc = 96
			case 96:
				if (!($g[33]>1)) {
					$pc = 98
					continue
				}
				$pc = 97
				if (wait(1)) {
					return
				}
			case 97:
				$pc = 96
				continue
			case 98:
				$pc = 99
			case 99:
				$return(2)
				continue
			case 100:
				$enter(10);	// handleMsg
				$pc = 101
			case 101:
				if (!(1)) {
					$pc = 176
					continue
				}
				$pc = 102
			case 102:
				if (!($obj.$msgQ.$head)) {
					$pc = 174
					continue
				}
				$stack[$fp+5]=$obj.$msgQ.$pop()
				if (!($stack[$fp+5].$dstCPU!=BROADCAST&&$stack[$fp+5].$dstCPU!=$obj.$cpuN)) {
					$pc = 103
					continue
				}
				fork(38, $obj, $stack[$fp+5].$dstCPU, $stack[$fp+5])
				$pc = 102
				continue
			case 103:
				$stack[$fp+5].setOpacity(0)
				if (!($stack[$fp+5].$op==GETS||$stack[$fp+5].$op==GETX)) {
					$pc = 131
					continue
				}
				if (!($stack[$fp+5].$srcCPU!=$obj.$cpuN)) {
					$pc = 108
					continue
				}
				$stack[$fp+6]=0
				$pc = 104
			case 104:
				if (!($stack[$fp+6]<NLINK)) {
					$pc = 107
					continue
				}
				if (!($obj.$txLink[$stack[$fp+6]]&&$g[59][$obj.$txLink[$stack[$fp+6]].$dstCPU][$stack[$fp+5].$srcCPU]==$obj.$cpuN)) {
					$pc = 105
					continue
				}
				fork(38, $obj, $obj.$txLink[$stack[$fp+6]].$dstCPU, newMsg($stack[$fp+5].$srcCPU, BROADCAST, $stack[$fp+5].$op, $stack[$fp+5].$data[0]))
				$pc = 105
			case 105:
				$pc = 106
			case 106:
				$stack[$fp+6]++
				$pc = 104
				continue
			case 107:
				$pc = 108
			case 108:
				$stack[$fp+4]=$stack[$fp+5].$data[0]&1
				if (!($obj.$cache.$xfrOwnerLock[$stack[$fp+4]])) {
					$pc = 109
					continue
				}
				$obj.$cache.$xfrOwnerMsgQ[$stack[$fp+4]].$push($stack[$fp+5])
				$pc = 102
				continue
			case 109:
				if (!($stack[$fp+5].$op==GETS)) {
					$pc = 120
					continue
				}
				if (!($obj.$op!=NOP&&$obj.$opAddr==$stack[$fp+5].$data[0]&&$stack[$fp+5].$srcCPU!=$obj.$cpuN)) {
					$pc = 110
					continue
				}
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg($obj.$cpuN, $stack[$fp+5].$srcCPU, CNFL, 0))
				$pc = 119
				continue
			case 110:
				if (!($obj.$cache.$hit($stack[$fp+5].$data[0])==0)) {
					$pc = 113
					continue
				}
				$stack[$fp+4]=$stack[$fp+5].$data[0]&1
				if (!($obj.$cache.$state[$stack[$fp+4]]==M)) {
					$pc = 111
					continue
				}
				$stack[$fp+1]=$obj.$cache.$addr[$stack[$fp+4]]
				debug("write back (MISS) addr=%d set=%d", $stack[$fp+1], $stack[$fp+4])
				fork(38, $obj, $obj.$a2CPU($stack[$fp+1]), newMsg2($obj.$cpuN, $obj.$a2CPU($stack[$fp+1]), WB, $stack[$fp+1], $obj.$cache.$data[$stack[$fp+4]]))
				$obj.$cache.$setState($stack[$fp+1], E)
				$obj.$cache.$xfrOwnerLock[$stack[$fp+4]]=1
				$obj.$cache.$xfrOwnerLockR[$stack[$fp+4]].setOpacity(1)
				$obj.$cache.$xfrOwnerMsgQ[$stack[$fp+4]].$push($stack[$fp+5])
				$pc = 102
				continue
			case 111:
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg($obj.$cpuN, $stack[$fp+5].$srcCPU, IACK, $stack[$fp+5].$data[0]))
				$pc = 112
			case 112:
				$pc = 118
				continue
			case 113:
				if (!($obj.$cache.$state[$stack[$fp+4]]==S)) {
					$pc = 114
					continue
				}
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg($obj.$cpuN, $stack[$fp+5].$srcCPU, SACK, $stack[$fp+5].$data[0]))
				$pc = 117
				continue
			case 114:
				if (!($obj.$cache.$state[$stack[$fp+4]]==E||$obj.$cache.$state[$stack[$fp+4]]==F)) {
					$pc = 115
					continue
				}
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg2($obj.$cpuN, $stack[$fp+5].$srcCPU, DATAF, $obj.$cache.$addr[$stack[$fp+4]], $obj.$cache.$data[$stack[$fp+4]]))
				$obj.$cache.$setState($stack[$fp+1], S)
				$obj.$cache.$xfrOwnerLock[$stack[$fp+4]]=1
				$obj.$cache.$xfrOwnerLockR[$stack[$fp+4]].setOpacity(1)
				$pc = 116
				continue
			case 115:
				$stack[$fp+1]=$obj.$cache.$addr[$stack[$fp+4]]
				debug("write back (HIT) addr=%d set=%d", $stack[$fp+1], $stack[$fp+4])
				fork(38, $obj, $obj.$a2CPU($stack[$fp+1]), newMsg2($obj.$cpuN, $obj.$a2CPU($stack[$fp+1]), WB, $stack[$fp+1], $obj.$cache.$data[$stack[$fp+4]]))
				$obj.$cache.$setState($stack[$fp+1], E)
				$obj.$cache.$xfrOwnerLock[$stack[$fp+4]]=1
				$obj.$cache.$xfrOwnerLockR[$stack[$fp+4]].setOpacity(1)
				$obj.$cache.$xfrOwnerMsgQ[$stack[$fp+4]].$push($stack[$fp+5])
				$pc = 102
				continue
			case 116:
				$pc = 117
			case 117:
				$pc = 118
			case 118:
				$pc = 119
			case 119:
				$pc = 130
				continue
			case 120:
				if (!($obj.$cache.$hit($stack[$fp+5].$data[0])==0)) {
					$pc = 121
					continue
				}
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg($obj.$cpuN, $stack[$fp+5].$srcCPU, IACK, $stack[$fp+5].$data[0]))
				$pc = 129
				continue
			case 121:
				$stack[$fp+4]=$stack[$fp+5].$data[0]&1
				if (!($obj.$cache.$state[$stack[$fp+4]]==S)) {
					$pc = 122
					continue
				}
				debug("here S")
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg($obj.$cpuN, $stack[$fp+5].$srcCPU, IACK, $stack[$fp+5].$data[0]))
				$pc = 127
				continue
			case 122:
				if (!($obj.$cache.$state[$stack[$fp+4]]==E)) {
					$pc = 123
					continue
				}
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg2($obj.$cpuN, $stack[$fp+5].$srcCPU, DATAE, $obj.$cache.$addr[$stack[$fp+4]], $obj.$cache.$data[$stack[$fp+4]]))
				$pc = 126
				continue
			case 123:
				if (!($obj.$cache.$state[$stack[$fp+4]]==M)) {
					$pc = 124
					continue
				}
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg2($obj.$cpuN, $stack[$fp+5].$srcCPU, DATAM, $obj.$cache.$addr[$stack[$fp+4]], $obj.$cache.$data[$stack[$fp+4]]))
				$pc = 125
				continue
			case 124:
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg2($obj.$cpuN, $stack[$fp+5].$srcCPU, DATAE, $obj.$cache.$addr[$stack[$fp+4]], $obj.$cache.$data[$stack[$fp+4]]))
				$pc = 125
			case 125:
				$pc = 126
			case 126:
				$pc = 127
			case 127:
				if (!($obj.$cache.$state[$stack[$fp+4]]!=S)) {
					$pc = 128
					continue
				}
				$obj.$cache.$xfrOwnerLock[$stack[$fp+4]]=1
				$obj.$cache.$xfrOwnerLockR[$stack[$fp+4]].setOpacity(1)
				$pc = 128
			case 128:
				$obj.$cache.$setState($stack[$fp+5].$data[0], I)
				$pc = 129
			case 129:
				$pc = 130
			case 130:
				$pc = 173
				continue
			case 131:
				if (!(($stack[$fp+5].$op==IACK)||($stack[$fp+5].$op==SACK))) {
					$pc = 136
					continue
				}
				if (!($stack[$fp+5].$op==SACK)) {
					$pc = 132
					continue
				}
				$obj.$opFlags|=1
				$pc = 132
			case 132:
				if (!(++$obj.$opReplyCnt==NCPU)) {
					$pc = 135
					continue
				}
				$stack[$fp+1]=$stack[$fp+5].$data[0]
				if (!($obj.$opFormerOwner==-1)) {
					$pc = 133
					continue
				}
				fork(38, $obj, $obj.$a2CPU($stack[$fp+1]), newMsg2($obj.$cpuN, $obj.$a2CPU($stack[$fp+1]), READ, $stack[$fp+1], $obj.$opConflictMask))
				$pc = 134
				continue
			case 133:
				$g[33]++
				fork(38, $obj, $obj.$a2CPU($stack[$fp+1]), newMsg3($obj.$cpuN, $obj.$a2CPU($stack[$fp+1]), CNCL, $stack[$fp+1], $obj.$opFormerOwner, $obj.$opConflictMask))
				$obj.$opFormerOwner=-1
				$pc = 134
			case 134:
				$pc = 135
			case 135:
				$pc = 172
				continue
			case 136:
				if (!($stack[$fp+5].$op==READ)) {
					$pc = 139
					continue
				}
				debug("[from CPU%d]:READ addr=%d conflicts=%d", $stack[$fp+5].$srcCPU, $stack[$fp+5].$data[0], $stack[$fp+5].$data[1])
				$stack[$fp+1]=$stack[$fp+5].$data[0]
				$stack[$fp+3]=$stack[$fp+5].$data[1]
				$stack[$fp+7]=$obj.$memOp[$stack[$fp+1]%NMEM].$conflicts
				$obj.$memOp[$stack[$fp+1]%NMEM].$conflicts|=$stack[$fp+3]
				if (!($stack[$fp+7])) {
					$pc = 137
					continue
				}
				$stack[$fp+8]=$obj.$memOp[$stack[$fp+1]%NMEM].$owner
				fork(38, $obj, $stack[$fp+8], newMsg2($obj.$cpuN, $stack[$fp+8], XFR, $stack[$fp+1], $stack[$fp+5].$srcCPU))
				$pc = 138
				continue
			case 137:
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg2($obj.$cpuN, $stack[$fp+5].$srcCPU, DATAE, $stack[$fp+1], $obj.$mem.$data[$stack[$fp+1]%NMEM]))
				$pc = 138
			case 138:
				$obj.$memOp[$stack[$fp+1]%NMEM].$owner=$stack[$fp+5].$srcCPU
				$pc = 171
				continue
			case 139:
				if (!($stack[$fp+5].$op==CNCL)) {
					$pc = 141
					continue
				}
				debug("[from CPU%d] CNCL addr=%d conflicts=%d", $stack[$fp+5].$srcCPU, $stack[$fp+5].$data[0], $stack[$fp+5].$data[2])
				$stack[$fp+1]=$stack[$fp+5].$data[0]
				$stack[$fp+3]=$stack[$fp+5].$data[2]
				if (!($stack[$fp+3])) {
					$pc = 140
					continue
				}
				debug("conflicts=%d", $stack[$fp+3])
				$pc = 140
			case 140:
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg($obj.$cpuN, $stack[$fp+5].$srcCPU, ACK, $stack[$fp+1]))
				fork(38, $obj, $stack[$fp+5].$data[1], newMsg($obj.$cpuN, $stack[$fp+5].$data[1], DACK, $stack[$fp+1]))
				$pc = 170
				continue
			case 141:
				if (!($stack[$fp+5].$op==WB)) {
					$pc = 142
					continue
				}
				$obj.$mem.$$update($stack[$fp+5].$data[0], $stack[$fp+5].$data[1])
				fork(38, $obj, $stack[$fp+5].$srcCPU, newMsg($obj.$cpuN, $stack[$fp+5].$srcCPU, ACK, $stack[$fp+5].$data[0]))
				$pc = 169
				continue
			case 142:
				if (!($stack[$fp+5].$op==DATAE)) {
					$pc = 147
					continue
				}
				$obj.$cache.$$update($obj.$opFlags&1 ? F : E, $stack[$fp+5].$data[0], $stack[$fp+5].$data[1])
				if (!($obj.$op==READOP)) {
					$pc = 143
					continue
				}
				fork(79, $obj, $stack[$fp+5].$data[0], $stack[$fp+5].$data[1], $obj.$opReplyCnt==NCPU)
				$pc = 144
				continue
			case 143:
				fork($obj.$writeFinish, $obj, $stack[$fp+5].$data[0], $obj.$opReplyCnt==NCPU)
				$pc = 144
			case 144:
				if (!($obj.$opReplyCnt<NCPU)) {
					$pc = 146
					continue
				}
				$obj.$opFormerOwner=$stack[$fp+5].$srcCPU
				if (!(++$obj.$opReplyCnt==NCPU)) {
					$pc = 145
					continue
				}
				$g[33]++
				fork(38, $obj, $obj.$a2CPU($obj.$opAddr), newMsg3($obj.$cpuN, $obj.$a2CPU($obj.$opAddr), CNCL, $obj.$opAddr, $obj.$opFormerOwner, $obj.$opConflictMask))
				$pc = 145
			case 145:
				$pc = 146
			case 146:
				$pc = 168
				continue
			case 147:
				if (!($stack[$fp+5].$op==DATAM)) {
					$pc = 150
					continue
				}
				$obj.$cache.$$update(M, $stack[$fp+5].$data[0], $stack[$fp+5].$data[1])
				fork($obj.$writeFinish, $obj, $stack[$fp+5].$data[0], $obj.$opReplyCnt==NCPU)
				if (!($obj.$opReplyCnt<NCPU)) {
					$pc = 149
					continue
				}
				$obj.$opFormerOwner=$stack[$fp+5].$srcCPU
				if (!(++$obj.$opReplyCnt==NCPU)) {
					$pc = 148
					continue
				}
				$g[33]++
				fork(38, $obj, $obj.$a2CPU($obj.$opAddr), newMsg3($obj.$cpuN, $obj.$a2CPU($obj.$opAddr), CNCL, $obj.$opAddr, $obj.$opFormerOwner, $obj.$opConflictMask))
				$pc = 148
			case 148:
				$pc = 149
			case 149:
				$pc = 167
				continue
			case 150:
				if (!($stack[$fp+5].$op==DATAF)) {
					$pc = 153
					continue
				}
				$obj.$cache.$$update(F, $stack[$fp+5].$data[0], $stack[$fp+5].$data[1])
				fork(79, $obj, $stack[$fp+5].$data[0], $stack[$fp+5].$data[1], $obj.$opReplyCnt==NCPU)
				if (!($obj.$opReplyCnt<NCPU)) {
					$pc = 152
					continue
				}
				$obj.$opFormerOwner=$stack[$fp+5].$srcCPU
				if (!(++$obj.$opReplyCnt==NCPU)) {
					$pc = 151
					continue
				}
				$g[33]++
				fork(38, $obj, $obj.$a2CPU($obj.$opAddr), newMsg3($obj.$cpuN, $obj.$a2CPU($obj.$opAddr), CNCL, $obj.$opAddr, $obj.$opFormerOwner, $obj.$opConflictMask))
				$pc = 151
			case 151:
				$pc = 152
			case 152:
				$pc = 166
				continue
			case 153:
				if (!($stack[$fp+5].$op==ACK)) {
					$pc = 157
					continue
				}
				debug("ACK %d", $stack[$fp+5].$data[0])
				$stack[$fp+4]=$stack[$fp+5].$data[0]&1
				$obj.$cache.$xfrOwnerLock[$stack[$fp+4]]=0
				$obj.$cache.$xfrOwnerLockR[$stack[$fp+4]].setOpacity(0)
				$stack[$fp+2]=0
				$pc = 154
			case 154:
				if (!($obj.$cache.$xfrOwnerMsgQ[$stack[$fp+4]].$head)) {
					$pc = 155
					continue
				}
				debug("transfer msg.op=%d", $obj.$cache.$xfrOwnerMsgQ[$stack[$fp+4]].$head.$op)
				$obj.$msgQ.$push($obj.$cache.$xfrOwnerMsgQ[$stack[$fp+4]].$pop())
				$stack[$fp+2]=1
				$pc = 154
				continue
			case 155:
				if (!($stack[$fp+2]==0)) {
					$pc = 156
					continue
				}
				debug("ACK calling workEnd")
				workEnd()
				$pc = 156
			case 156:
				$pc = 165
				continue
			case 157:
				if (!($stack[$fp+5].$op==DACK)) {
					$pc = 158
					continue
				}
				$stack[$fp+4]=$stack[$fp+5].$data[0]&1
				$obj.$cache.$xfrOwnerLock[$stack[$fp+4]]=0
				$obj.$cache.$xfrOwnerLockR[$stack[$fp+4]].setOpacity(0)
				debug("DACK calling workEnd")
				workEnd()
				$pc = 164
				continue
			case 158:
				if (!($stack[$fp+5].$op==CNFL)) {
					$pc = 160
					continue
				}
				$obj.$opConflictMask|=(1<<$stack[$fp+5].$srcCPU)
				if (!(++$obj.$opReplyCnt==NCPU)) {
					$pc = 159
					continue
				}
				$g[33]++
				fork(38, $obj, $obj.$a2CPU($obj.$opAddr), newMsg2($obj.$cpuN, $obj.$a2CPU($obj.$opAddr), $obj.$opFormerOwner==-1 ? READ : CNCL, $obj.$opAddr, $obj.$opConflictMask))
				$pc = 159
			case 159:
				$pc = 163
				continue
			case 160:
				if (!($stack[$fp+5].$op==XFR)) {
					$pc = 162
					continue
				}
				$stack[$fp+1]=$stack[$fp+5].$data[0]
				$stack[$fp+9]=$obj.$cache.$state[$stack[$fp+1]&1]
				$stack[$fp+10]=$obj.$cache.$data[$stack[$fp+1]&1]
				if (!($stack[$fp+9]==E||$stack[$fp+9]==F)) {
					$pc = 161
					continue
				}
				fork(38, $obj, $stack[$fp+5].$data[1], newMsg2($obj.$cpuN, $stack[$fp+5].$data[1], DATAF, $stack[$fp+1], $stack[$fp+10]))
				$obj.$cache.$$update(S, $stack[$fp+1], $stack[$fp+10])
				$pc = 161
			case 161:
				$pc = 162
			case 162:
				$pc = 163
			case 163:
				$pc = 164
			case 164:
				$pc = 165
			case 165:
				$pc = 166
			case 166:
				$pc = 167
			case 167:
				$pc = 168
			case 168:
				$pc = 169
			case 169:
				$pc = 170
			case 170:
				$pc = 171
			case 171:
				$pc = 172
			case 172:
				$pc = 173
			case 173:
				freeMsg($stack[$fp+5])
				$pc = 102
				continue
			case 174:
				$pc = 175
				if (wait(1)) {
					return
				}
			case 175:
				$pc = 101
				continue
			case 176:
				$return(0)
				continue
			case 177:
				$enter(1);	// startTransactions
				start()
				$stack[$fp+1]=0
				$pc = 178
			case 178:
				if (!($stack[$fp+1]<NCPU)) {
					$pc = 180
					continue
				}
				fork(88, $g[58][$stack[$fp+1]])
				$pc = 179
			case 179:
				$stack[$fp+1]++
				$pc = 178
				continue
			case 180:
				$return(0)
				continue
			case 181:
				$enter(0);	// $eh7
				if (!($stack[$fp-3]&&($stack[$fp-4]&MB_LEFT))) {
					$pc = 182
					continue
				}
				reset()
				return
			case 182:
				$acc = 0
				$return(4)
				continue
			}
		}
	}

	this.$getCurrentThread = $getCurrentThread
	this.$execute = $execute
	this.$resumeThread = $resumeThread
	this.$suspendThread = $suspendThread
	this.$switchToThread = $switchToThread
	this.$testFlag = $testFlag

}

// eof
