<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="canonical" href="https://www.scss.tcd.ie/Jeremy.Jones/caches/cacheHelp.htm">
   <link rel="icon" type="image/x-icon" href="../vivio.ico">
  <title>VivioJS cache help</title>
  <script src="../funcs.js"></script>
  <script src="../vivio.js"></script>
  <script src="cache.js"></script>
</head>
<body style="background-color:#e0e0e0;">
  <script>
    header("Cache Animation");
  </script>
  <table style="margin-left:5%; width:90%; border:0; border-spacing:0; padding:0;">
    <tr>
      <td style="height:40px;">
        <p style="text-align:justify;"><br>
        This Vivio animation is designed to understand the operation of a CPU cache.</p>
        <p style="text-align:justify;">A sequence of addresses is fed through a software model of a cache. The sequence is selected by pressing the appropriate
        button and can be (i) the addresses given in <a href="https://www.scss.tcd.ie/Jeremy.Jones/CSU34021/t6.pdf">CSU34021 tutorial 6</a>, (ii) a repetitive sequence of 5 sequential addresses and
        (iii) a set of random addresses. The repetitive sequence can be used to show that, in some circumstances, a direct mapped cache can have a better
        hit-rate than a fully associative cache.</p>
        <p style="text-align:justify;">The organisation of the cache is specified by three parameters L, K and N which can be set by pressing the appropriate
        buttons. Only a subset of values are allowed as drawing large caches on a small screen is impractical. L is the number of bytes stored per cache line,
        K the cache associativity and N the number of sets. K=1 indicates a direct mapped cache and N=1 a fully associative cache. The cache size is L×K×N
        bytes.<br></p>
      </td>
    </tr>
    <tr>
      <td style="text-align:center; color:red;">
        <!-- tabindex needed for keyboard input -->
        <canvas id="canvas" tabindex="1" style="margin:auto; width:96%; max-width:1024px; display:block;">
          No canvas support
        </canvas>
        Click on diagram to activate animation or <a href="cache.htm">here</a> for a full screen version.
      </td>
    </tr>
    <tr>
      <td style="height:40px;">
        <p style="text-align:justify;"><br>
        The simulation is started and stopped by pressing the button marked "start" or "stop". The simulation is reset back to the beginning by pressing the
        "reset" button and the simulation speed can be speeded up and slowed down in a cyclic fashion by pressing the button marked "xx ticks/s". The animation
        can also be controlled by pressing the right-hand mouse button on the window background.</p>
        <p style="text-align:justify;">The cache is organised as a matrix of N×K tags together with a corresponding matrix of N×K cache lines. Each cache line
        holds L data bytes.</p>
        <p style="text-align:justify;">An incoming address is split into 3 fields. The low order log2(L) bits give the byte offset within a cache line (always
        4 byte aligned in simulation), the next log2(N) bits selects the set and the remaining high order bits are used as the address tag. The address tag is
        compared, in parallel, with all K tags of the selected set. If a match is found then we have a hit, otherwise a miss.</p>
        <p style="text-align:justify;">On a hit, the tags are re-ordered on a least recently used (LRU) basis. This is illustrated by using darker shades of
        gray for the older tags.</p>
        <p style="text-align:justify;">On a miss, a complete cache line (L bytes) is read from main memory and placed in the set's least recently used cache
        line. The corresponding tag and the tag ordering are updated.</p>
        <p style="text-align:justify;">The selected word (32 bits) from the cache line is returned to the CPU.<br></p>
      </td>
    </tr>
  </table><br>
  <script>
	vplayer = new VPlayer("canvas", cache);
	footer("caches");
  </script>
</body>
</html>
